{"pages":[],"posts":[{"title":"矩阵计算器","text":"线代必备工具 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;time.h&gt;#include&lt;graphics.h&gt;#include&lt;conio.h&gt;#include&lt;fstream&gt;#include&lt;string&gt;#include&lt;iostream&gt;double** 生成矩阵(double** a, int* r, int* c);double 计算行列式(double** a, int n);void 打开菜单();int 执行程序();void 写入文件(double** a, int r1, int c1, double** d, int r2, int c2, std::string name);void 写入逆矩阵(double** a, double** d, int r, std::string name);void 写入行列式(double** a, int r, double ss);void 写入秩(double** a, int r1, int c1, int 秩);void 写入加减法(double** a, int r1, int c1, double** b, double** d, int r, int c, int sign);void 写入乘法(double** a, int r1, int c1, double** b, int r2, int c2, double** d);void 读取文件();void 矩阵转置(double** a, int r, int c);void 矩阵加减法(double** a, double** b, int r1, int c1, int r2, int c2, int sign);void 矩阵数乘(double** a, int r, int c);void 矩阵乘法(double** a, double** b, int r1, int c1, int r2, int c2);int 矩阵化简(double** a, int r, int c, int sign);void 矩阵求逆(double** a, int r);void 打印d数组(double** d, int r, int c);void 打印d数组(double** d, int r);void 内存释放(double** d, int r);int main(){ int 开始; do { 打开菜单(); 开始 = 执行程序(); } while (开始 == 0);}void 矩阵转置(double** a, int r, int c){ double** d = NULL; d = new double* [c]; for (int i = 0; i &lt; c; i++) { d[i] = new double[r]; } for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; c; j++) { d[j][i] = a[i][j]; } } 打印d数组(d, c, r); 写入文件(a, r, c, d, c, r, &quot;的转置为：&quot;); 内存释放(d, c);}void 矩阵加减法(double** a, double** b, int r1, int c1, int r2, int c2, int sign){ if (r1 == r2 &amp;&amp; c1 == c1) { double** d = NULL; d = new double* [r1]; for (int i = 0; i &lt; r1; i++) { d[i] = new double[c1]; } for (int i = 0; i &lt; r1; i++) { for (int j = 0; j &lt; c1; j++) { d[i][j] = a[i][j] + b[i][j] * sign; } } 打印d数组(d, r1, c1); 写入加减法(a, r1, c1, b, d, r1, c1, sign); 内存释放(d, r1); } else printf(&quot;这两个矩阵不可以这样运算！&quot;);}void 矩阵数乘(double** a, int r, int c){ double** d = NULL; d = new double* [r]; for (int i = 0; i &lt; r; i++) { d[i] = new double[c]; } int k; printf(&quot;请输入数值：&quot;); scanf_s(&quot;%d&quot;, &amp;k); for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; c; j++) { d[i][j] = k * a[i][j]; } } 打印d数组(d, r, c); std::to_string(k); std::string name = &quot;数乘&quot; + std::to_string(k) + &quot;的结果为：&quot;; 写入文件(a, r, c, d, r, c, name); 内存释放(d, r);}void 矩阵乘法(double** a, double** b, int r1, int c1, int r2, int c2){ if (r2 == c1) { double** d = NULL, sum; d = new double* [r1]; for (int i = 0; i &lt; r1; i++) { d[i] = new double[c2]; } for (int i = 0; i &lt; r1; i++) { for (int j = 0; j &lt; c2; j++) { sum = 0; for (int k = 0; k &lt; c1; k++) { sum += a[i][k] * b[k][j]; } d[i][j] = sum; } } 打印d数组(d, r1, c2); 写入乘法(a, r1, c1, b, r2, c2, d); 内存释放(d, r1); } else printf(&quot;这两个矩阵不能相乘！&quot;);}int 矩阵化简(double** a, int r, int c, int sign){ double** d; d = new double* [r]; for (int i = 0; i &lt; r; i++) { d[i] = new double[c]; } for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; c; j++) { d[i][j] = a[i][j]; } } //起始行列 int cnt = 0; int cct = 0; int flag; double t; while (cnt &lt;= r &amp;&amp; cct &lt;= c) { flag = -1; for (int i = cnt; i &lt; r; i++) { if (d[i][cct] != 0) { flag = i; break; } } if (flag == -1) { cct++; continue; } //交换两行; if (flag != cnt) { double tmp = 0; for (int j = cct; j &lt; c; j++) { tmp = d[flag][j]; d[flag][j] = d[cnt][j]; d[cnt][j] = tmp; } } //化第一行首个为1 t = d[cnt][cct]; for (int j = cct; j &lt; c; j++) { d[cnt][j] /= t; } for (int i = cnt + 1; i &lt; r; i++) { if (d[i][cct] != 0) { t = d[i][cct]; for (int j = cct; j &lt; c; j++) { d[i][j] = d[i][j] - d[cnt][j] * t; } } } cnt++; cct++; } for (int i = r - 1; i &gt; 0; i--) { flag = -1; for (int j = 0; j &lt; c; j++) { if (d[i][j] != 0) { flag = j; break; } } if (flag != -1) { for (int k = i - 1; k &gt;= 0; k--) { t = d[k][flag]; for (int j = 0; j &lt; c; j++) { d[k][j] = d[k][j] - t * d[i][j]; } } } } int number = 0; for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; c; j++) { if (d[i][j] != 0) { number++; break; } } } if (sign == 0) { 打印d数组(d, r, c); 写入文件(a, r, c, d, r, c, &quot;的化简结果为：&quot;); } else { 打印d数组(d, r); 写入逆矩阵(a, d,r, &quot;的逆矩阵为: &quot;); } 内存释放(d, r); return number;}void 矩阵求逆(double** a, int r){ if (计算行列式(a, r) != 0) { double** d; d = new double* [r]; for (int i = 0; i &lt; r; i++) { d[i] = new double[2 * r]; } for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; r; j++) { d[i][j] = a[i][j]; } for (int j = r; j &lt; 2 * r; j++) { if (i == j - r) d[i][j] = 1; else d[i][j] = 0; } } 矩阵化简(d, r, 2 * r, 1); 内存释放(d, r); } else printf(&quot;这个矩阵不可逆！&quot;);}void 打印d数组(double** d, int r, int c){ printf(&quot;结果如下：\\n&quot;); for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; c; j++) { if ((int)(d[i][j] * 100) % 100 == 0) printf(&quot;%d\\t&quot;, (int)d[i][j]); else printf(&quot;%.2lf\\t&quot;, d[i][j]); } printf(&quot;\\n&quot;); }}void 打印d数组(double** d, int r){ printf(&quot;结果如下：\\n&quot;); for (int i = 0; i &lt; r; i++) { for (int j = r; j &lt; 2 * r; j++) { if ((int)(d[i][j] * 100) % 100 == 0) printf(&quot;%d\\t&quot;, (int)d[i][j]); else printf(&quot;%.2lf\\t&quot;, d[i][j]); } printf(&quot;\\n&quot;); }}double 计算行列式(double** a, int n){ double** d; d = new double* [n]; for (int i = 0; i &lt; n; i++) { d[i] = new double[n]; } for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { d[j][i] = a[i][j]; } } int flag = -1; for (int i = 0; i &lt; n; i++) { if (d[i][0] != 0) { flag = i; break; } } if (flag != 0) { double tmp = 0; for (int j = 0; j &lt; n; j++) { tmp = d[flag][j]; d[flag][j] = d[0][j]; d[0][j] = tmp; } } double tmp; for (int k = 1; k &lt; n; k++) { for (int i = k; i &lt; n; i++) { tmp = d[i][k - 1] / d[k - 1][k - 1]; for (int j = k - 1; j &lt; n; j++) { d[i][j] = d[i][j] - tmp * d[k - 1][j]; } } } double ss = 1; for (int i = 0; i &lt; n; i++) { ss *= d[i][i]; } 写入行列式(a, n, ss); 内存释放(d, n); return ss;}double** 生成矩阵(double** a, int* r, int* c){ printf(&quot;请输入矩阵的行数，列数：&quot;); scanf_s(&quot;%d%d&quot;, r, c); printf(&quot;请输入矩阵：\\n&quot;); a = new double* [*r]; for (int i = 0; i &lt; *r; i++) { a[i] = new double[*c]; } for (int i = 0; i &lt; *r; i++) { for (int j = 0; j &lt; *c; j++) { scanf_s(&quot;%lf&quot;, &amp;a[i][j]); } } return a;}void 打开菜单(){ printf(&quot;=======================================================================\\n&quot;); printf(&quot;| ----------1|我要求矩阵的加法 ----------- |\\n&quot;); printf(&quot;| ----------2|我要求矩阵的减法 ----------- |\\n&quot;); printf(&quot;| ----------3|我要求矩阵的转置 ----------- |\\n&quot;); printf(&quot;| ----------4|我要求矩阵的逆矩阵----------- |\\n&quot;); printf(&quot;| ----------5|我要求最简行矩阵 ----------- |\\n&quot;); printf(&quot;| ----------6|我要求矩阵的数乘 ----------- |\\n&quot;); printf(&quot;| ----------7|我要求矩阵的乘法 ----------- |\\n&quot;); printf(&quot;| ----------8|我要求矩阵的秩 ----------- |\\n&quot;); printf(&quot;| ----------9|我要计算行列式的值----------- |\\n&quot;); printf(&quot;| ----------0|读取计算结果文件 ----------- |\\n&quot;); printf(&quot;| ----------QAQ|输入字母可以退出----------- |\\n&quot;); printf(&quot;=======================================================================\\n&quot;);}int 执行程序(){ double** a = NULL, ** b = NULL; int r1, c1, r2, c2; char ch; switch (ch = getchar()) { case'1': { a = 生成矩阵(a, &amp;r1, &amp;c1); b = 生成矩阵(b, &amp;r2, &amp;c2); 矩阵加减法(a, b, r1, c1, r2, c2, 1); 内存释放(a, r1); 内存释放(b, r2); break; } case'2': { a = 生成矩阵(a, &amp;r1, &amp;c1); b = 生成矩阵(b, &amp;r2, &amp;c2); 矩阵加减法(a, b, r1, c1, r2, c2, -1); 内存释放(a, r1); 内存释放(b, r2); break; } case'3': { a = 生成矩阵(a, &amp;r1, &amp;c1); 矩阵转置(a, r1, c1); 内存释放(a, r1); break; } case'4': { a = 生成矩阵(a, &amp;r1, &amp;c1); 矩阵求逆(a, r1); 内存释放(a, r1); break; } case'5': { a = 生成矩阵(a, &amp;r1, &amp;c1); 矩阵化简(a, r1, c1, 0); 内存释放(a, r1); break; } case'6': { a = 生成矩阵(a, &amp;r1, &amp;c1); 矩阵数乘(a, r1, c1); 内存释放(a, r1); break; } case'7': { a = 生成矩阵(a, &amp;r1, &amp;c1); b = 生成矩阵(b, &amp;r2, &amp;c2); 矩阵乘法(a, b, r1, c1, r2, c2); 内存释放(a, r1); 内存释放(b, r2); break; } case'8': { a = 生成矩阵(a, &amp;r1, &amp;c1); int 秩; 秩 = 矩阵化简(a, r1, c1, 0); printf(&quot;矩阵的秩为：%d\\n&quot;, 秩); 内存释放(a, r1); break; } case'9': { a = 生成矩阵(a, &amp;r1, &amp;c1); double ss = 计算行列式(a, r1); if ((int)(ss * 100) % 100 == 0) printf(&quot;%d\\t&quot;, (int)ss); else printf(&quot;%.2lf\\t&quot;, ss); 内存释放(a, r1); break; } case '0': { 读取文件(); break; } default: { return -1; } } getchar(); return 0;}void 内存释放(double** d, int r){ for (int i = 0; i &lt; r; i++) { delete[]d[i]; } delete[]d;}void 写入文件(double** a, int r1, int c1, double** d, int r2, int c2,std::string name){ using namespace std; string 文件名; 文件名 = &quot;计算结果.txt&quot;; ofstream fout(文件名.c_str(),ios_base::out|ios_base::app); fout &lt;&lt; &quot;矩阵：&quot; &lt;&lt; endl; for (int i = 0; i &lt; r1; i++) { for (int j = 0; j &lt; c1; j++) { if ((int)(a[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)a[i][j] &lt;&lt; &quot;\\t&quot;; else { fout &lt;&lt; a[i][j] &lt;&lt; &quot;\\t&quot;; } } fout &lt;&lt; endl; } fout &lt;&lt; name &lt;&lt; endl; for (int i = 0; i &lt; r2; i++) { for (int j = 0; j &lt; c2; j++) { if ((int)(d[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)d[i][j] &lt;&lt; &quot;\\t&quot;; else fout &lt;&lt; d[i][j] &lt;&lt; &quot;\\t&quot;; } fout &lt;&lt; endl; }}void 写入逆矩阵(double** a, double** d,int r, std::string name){ using namespace std; string 文件名; 文件名 = &quot;计算结果.txt&quot;; ofstream fout(文件名.c_str(), ios_base::out | ios_base::app); fout &lt;&lt; &quot;矩阵：&quot; &lt;&lt; endl; for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; r; j++) { if ((int)(a[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)a[i][j] &lt;&lt; &quot;\\t&quot;; else { fout &lt;&lt; a[i][j] &lt;&lt; &quot;\\t&quot;; } } fout &lt;&lt; endl; } fout &lt;&lt; name &lt;&lt; endl; for (int i = 0; i &lt; r; i++) { for (int j = r; j &lt; 2*r; j++) { if ((int)(d[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)d[i][j] &lt;&lt; &quot;\\t&quot;; else { fout &lt;&lt; d[i][j] &lt;&lt; &quot;\\t&quot;; } } fout &lt;&lt; endl; }}void 写入行列式(double** a, int r,double ss){ using namespace std; string 文件名; 文件名 = &quot;计算结果.txt&quot;; ofstream fout(文件名.c_str(), ios_base::out | ios_base::app); fout &lt;&lt; &quot;矩阵：&quot; &lt;&lt; endl; for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; r; j++) { if ((int)(a[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)a[i][j] &lt;&lt; &quot;\\t&quot;; else { fout &lt;&lt; a[i][j] &lt;&lt; &quot;\\t&quot;; } } fout &lt;&lt; endl; } fout &lt;&lt; &quot;的行列式的值为：&quot; &lt;&lt; ss &lt;&lt; endl;}void 写入秩(double** a, int r1, int c1, int 秩){ using namespace std; string 文件名; 文件名 = &quot;计算结果.txt&quot;; ofstream fout(文件名.c_str(), ios_base::out | ios_base::app); fout &lt;&lt; &quot;矩阵：&quot; &lt;&lt; endl; for (int i = 0; i &lt; r1; i++) { for (int j = 0; j &lt; 1; j++) { if ((int)(a[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)a[i][j] &lt;&lt; &quot;\\t&quot;; else { fout &lt;&lt; a[i][j] &lt;&lt; &quot;\\t&quot;; } } fout &lt;&lt; endl; } fout &lt;&lt; &quot;的秩为：&quot; &lt;&lt; 秩 &lt;&lt; endl;}void 写入加减法(double** a, int r1, int c1, double** b,double**d,int r,int c, int sign){ using namespace std; string 文件名; 文件名 = &quot;计算结果.txt&quot;; ofstream fout(文件名.c_str(), ios_base::out | ios_base::app); fout &lt;&lt; &quot;矩阵：&quot; &lt;&lt; endl; for (int i = 0; i &lt; r1; i++) { for (int j = 0; j &lt; c1; j++) { if ((int)(a[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)a[i][j] &lt;&lt; &quot;\\t&quot;; else { fout &lt;&lt; a[i][j] &lt;&lt; &quot;\\t&quot;; } } fout &lt;&lt; endl; } if (sign == 1) { fout &lt;&lt; &quot;加矩阵：&quot; &lt;&lt; endl; } else { fout &lt;&lt; &quot;减矩阵：&quot; &lt;&lt; endl; } for (int i = 0; i &lt; r1; i++) { for (int j = 0; j &lt; c1; j++) { if ((int)(b[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)b[i][j] &lt;&lt; &quot;\\t&quot;; else fout &lt;&lt; b[i][j] &lt;&lt; &quot;\\t&quot;; } fout &lt;&lt; endl; } fout &lt;&lt; &quot;的结果为：&quot; &lt;&lt; endl; for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; c; j++) { if ((int)(d[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)d[i][j] &lt;&lt; &quot;\\t&quot;; else fout &lt;&lt; d[i][j] &lt;&lt; &quot;\\t&quot;; } fout &lt;&lt; endl; }}void 写入乘法(double**a,int r1,int c1,double**b,int r2,int c2,double**d){ using namespace std; string 文件名; 文件名 = &quot;计算结果.txt&quot;; ofstream fout(文件名.c_str(), ios_base::out | ios_base::app); fout &lt;&lt; &quot;矩阵：&quot; &lt;&lt; endl; for (int i = 0; i &lt; r1; i++) { for (int j = 0; j &lt; c1; j++) { if ((int)(a[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)a[i][j] &lt;&lt; &quot;\\t&quot;; else { fout &lt;&lt; a[i][j] &lt;&lt; &quot;\\t&quot;; } } fout &lt;&lt; endl; } fout &lt;&lt; &quot;乘矩阵：&quot; &lt;&lt; endl; for (int i = 0; i &lt; r2; i++) { for (int j = 0; j &lt; c2; j++) { if ((int)(b[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)b[i][j] &lt;&lt; &quot;\\t&quot;; else fout &lt;&lt; b[i][j] &lt;&lt; &quot;\\t&quot;; } fout &lt;&lt; endl; } fout &lt;&lt; &quot;的结果为：&quot; &lt;&lt; endl; for (int i = 0; i &lt; r1; i++) { for (int j = 0; j &lt; c2; j++) { if ((int)(d[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)d[i][j] &lt;&lt; &quot;\\t&quot;; else fout &lt;&lt; d[i][j] &lt;&lt; &quot;\\t&quot;; } fout &lt;&lt; endl; }}void 读取文件(){ using namespace std; char ch; string 文件名; 文件名 = &quot;计算结果.txt&quot;; ifstream fin(文件名); if (fin.is_open()) { while (fin.get(ch)) { cout &lt;&lt; ch; } fin.close(); }}","link":"/2020/12/31/%E7%9F%A9%E9%98%B5%E8%AE%A1%E7%AE%97%E5%99%A8/"},{"title":"2048小游戏","text":"基于easyx，这是我做的第一个游戏 1.2048字符版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;#include&lt;conio.h&gt;#include&lt;graphics.h&gt;int main(){ using namespace std; int a[6][6], 备份[6][6]; int i, j, k; srand((int)time(0)); //初始化数组a,并且随机产生两个2 for (i = 1;i &lt; 5;i++) { for (j = 1;j &lt; 5;j++) { a[i][j] = 0; 备份[i][j] = 0; } } for (i = 0;i &lt; 6;i++) { a[i][0] = 5; a[i][5] = 5; a[0][i] = 5; a[5][i] = 5; } int i1, i2, j1, j2; do { i1 = rand() % 4 + 1; i2 = rand() % 4 + 1; j1 = rand() % 4 + 1; j2 = rand() % 4 + 1; } while (i1 == i2 &amp;&amp; j1 == j2); a[i1][j1] = 2; a[i2][j2] = 2; //打印初始数组 for (i = 1;i &lt; 5;i++) { for (j = 1;j &lt; 5;j++) { cout &lt;&lt; a[i][j]&lt;&lt;&quot;\\t&quot;; } cout &lt;&lt; endl; } cout &lt;&lt; endl; //键盘输入，后，随机一个格子生成一个数字 int ch, ch1, flag, tmp = 0, 为了符合规则[6][6];// 4 4 2 2 动过的不再动 while (1) { for (i = 0;i &lt; 6;i++) { for (j = 0;j &lt; 6;j++) { 为了符合规则[i][j] = 0; } } if (_kbhit) { ch1 = _getch(); ch = _getch(); //右移 if ((ch1 == 224 &amp;&amp; ch == 77) || (ch == 228 &amp;&amp; ch1 == 163)) { for (i = 1;i &lt;= 4;i++) { for (j = 3;j &gt;= 1;j--) { if (a[i][j] != 0) { flag = j; for (k = j + 1;k &lt;= 4;k++) { if (a[i][k] == 0) flag = k; else break; } //交换aij和aiflag; if (a[i][flag + 1] == a[i][j]&amp;&amp;为了符合规则[i][flag+1]==0) { a[i][flag + 1] *= 2; a[i][j] = 0; 为了符合规则[i][flag + 1] = 1; } else { tmp = a[i][j]; a[i][j] = a[i][flag]; a[i][flag] = tmp; } } } } } //下移 if ((ch1 == 224 &amp;&amp; ch == 80) || (ch == 243 &amp;&amp; ch1 == 163)) { for (j = 1;j &lt;= 4;j++) { for (i = 3;i &gt;= 1;i--) { if (a[i][j] != 0) { flag = i; for (k = i + 1;k &lt;=4;k++) { if (a[k][j] == 0) flag = k; else break; } /*if (a[i][j] == a[i][j - 1]) { a[i][j- 1] *= 2; a[i][j] = 0; }*/ //交换aij和aiflag; if (a[flag + 1][j] == a[i][j] &amp;&amp; 为了符合规则[flag + 1][j] == 0) { a[flag + 1][j] *= 2; 为了符合规则[flag + 1][j] = 1; a[i][j] = 0; } else { tmp = a[i][j]; a[i][j] = a[flag][j]; a[flag][j] = tmp; } } } } } //上移 if ((ch1 == 224 &amp;&amp; ch == 72) || (ch == 247 &amp;&amp; ch1 == 163)) { for (j = 1;j &lt;= 4;j++) { for (i = 2;i &lt;= 4;i++) { if (a[i][j] != 0) { flag = i; for (k = i - 1;k &gt;= 1;k--) { if (a[k][j] == 0) flag = k; else break; } /*if (a[i][j] == a[i][j - 1]) { a[i][j- 1] *= 2; a[i][j] = 0; }*/ //交换aij和aiflag; if (a[flag - 1][j] == a[i][j] &amp;&amp; 为了符合规则[flag - 1][j] == 0) { a[flag - 1][j] *= 2; 为了符合规则[flag - 1][j] = 1; a[i][j] = 0; } else { tmp = a[i][j]; a[i][j] = a[flag][j]; a[flag][j] = tmp; } } } } } //左移 if ((ch1 == 224 &amp;&amp; ch == 75) || (ch == 225 &amp;&amp; ch1 == 163)) { for (i = 1;i &lt;= 4;i++) { for (j = 2;j &lt;= 4;j++) { if (a[i][j] != 0) { flag = j; for (k = j - 1;k &gt;= 1;k--) { if (a[i][k] == 0) flag = k; else break; } /*if (a[i][j] == a[i][j - 1]) { a[i][j- 1] *= 2; a[i][j] = 0; }*/ //交换aij和aiflag; if (a[i][flag - 1] == a[i][j] &amp;&amp; 为了符合规则[i][flag - 1] == 0) { a[i][flag - 1] *= 2; 为了符合规则[i][flag - 1] = 1; a[i][j] = 0; } else { tmp = a[i][j]; a[i][j] = a[i][flag]; a[i][flag] = tmp; } } } } } } //空余位置随机生成一个2或者4 int i3, j3, kk; do { i3 = rand() % 4 + 1; j3 = rand() % 4 + 1; } while (a[i3][j3] != 0); kk = rand() % 2; if (kk == 1) a[i3][j3] = 2; else a[i3][j3] = 4; //打印a数组 for (i = 1;i &lt; 5;i++) { for (j = 1;j &lt; 5;j++) { cout &lt;&lt; a[i][j] &lt;&lt; &quot;\\t&quot;; } cout &lt;&lt; endl; } cout &lt;&lt; endl; }} 2.2048图像版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;#include&lt;conio.h&gt;#include&lt;graphics.h&gt;void 初始化屏幕(){ initgraph(1000, 1000); setbkcolor(WHITE); cleardevice(); int i, j; setcolor(BLACK); setfillcolor(YELLOW); for (i = 100;i &lt; 500;i+=100) { for (j = 100;j &lt; 500;j+=100) { rectangle(i, j, 100+i, j+100); fillrectangle(i, j, 100 + i, j + 100); } } settextstyle(25, 25, _T(&quot;隶书&quot;)); setbkmode(TRANSPARENT); BeginBatchDraw();}int main(){ using namespace std; 初始化屏幕(); int a[6][6], 备份[6][6]; int i, j, k; srand((int)time(0)); //初始化数组a,并且随机产生两个2 for (i = 1;i &lt; 5;i++) { for (j = 1;j &lt; 5;j++) { a[i][j] = 0; 备份[i][j] = 0; } } for (i = 0;i &lt; 6;i++) { a[i][0] = 5; a[i][5] = 5; a[0][i] = 5; a[5][i] = 5; } int i1, i2, j1, j2; do { i1 = rand() % 4 + 1; i2 = rand() % 4 + 1; j1 = rand() % 4 + 1; j2 = rand() % 4 + 1; } while (i1 == i2 &amp;&amp; j1 == j2); a[i1][j1] = 2; a[i2][j2] = 2; //打印初始数组 for (i = 1;i &lt; 5;i++) { for (j = 1;j &lt; 5;j++) { if (a[i][j] != 0) { TCHAR s[5]; _stprintf_s(s, _T(&quot;%d&quot;), a[i][j]); /*outtextxy(j * 100 + 25, i * 100 + 25, s);*/ RECT r = { 100 * j, 100 * i, 100 + 100 * j, 100 + 100 * i }; drawtext(s, &amp;r, DT_CENTER | DT_VCENTER | DT_SINGLELINE); } } } FlushBatchDraw(); //键盘输入，后，随机一个格子生成一个数字 int ch, ch1, flag, tmp = 0, 为了符合规则[6][6],旗子;// 4 4 2 2 动过的不再动 while (1) { 旗子 = 1; for (i = 0;i &lt; 6;i++) { for (j = 0;j &lt; 6;j++) { 备份[i][j] = a[i][j]; } } for (i = 0;i &lt; 6;i++) { for (j = 0;j &lt; 6;j++) { 为了符合规则[i][j] = 0; } } if (_kbhit) { ch1 = _getch(); ch = _getch(); //右移 if ((ch1 == 224 &amp;&amp; ch == 77) || (ch == 228 &amp;&amp; ch1 == 163)) { for (i = 1;i &lt;= 4;i++) { for (j = 3;j &gt;= 1;j--) { if (a[i][j] != 0) { flag = j; for (k = j + 1;k &lt;= 4;k++) { if (a[i][k] == 0) flag = k; else break; } //交换aij和aiflag; if (a[i][flag + 1] == a[i][j] &amp;&amp; 为了符合规则[i][flag + 1] == 0) { a[i][flag + 1] *= 2; a[i][j] = 0; 为了符合规则[i][flag + 1] = 1; } else { tmp = a[i][j]; a[i][j] = a[i][flag]; a[i][flag] = tmp; } } } } } //下移 if ((ch1 == 224 &amp;&amp; ch == 80) || (ch == 243 &amp;&amp; ch1 == 163)) { for (j = 1;j &lt;= 4;j++) { for (i = 3;i &gt;= 1;i--) { if (a[i][j] != 0) { flag = i; for (k = i + 1;k &lt;= 4;k++) { if (a[k][j] == 0) flag = k; else break; } /*if (a[i][j] == a[i][j - 1]) { a[i][j- 1] *= 2; a[i][j] = 0; }*/ //交换aij和aiflag; if (a[flag + 1][j] == a[i][j] &amp;&amp; 为了符合规则[flag + 1][j] == 0) { a[flag + 1][j] *= 2; 为了符合规则[flag + 1][j] = 1; a[i][j] = 0; } else { tmp = a[i][j]; a[i][j] = a[flag][j]; a[flag][j] = tmp; } } } } } //上移 if ((ch1 == 224 &amp;&amp; ch == 72) || (ch == 247 &amp;&amp; ch1 == 163)) { for (j = 1;j &lt;= 4;j++) { for (i = 2;i &lt;= 4;i++) { if (a[i][j] != 0) { flag = i; for (k = i - 1;k &gt;= 1;k--) { if (a[k][j] == 0) flag = k; else break; } /*if (a[i][j] == a[i][j - 1]) { a[i][j- 1] *= 2; a[i][j] = 0; }*/ //交换aij和aiflag; if (a[flag - 1][j] == a[i][j] &amp;&amp; 为了符合规则[flag - 1][j] == 0) { a[flag - 1][j] *= 2; 为了符合规则[flag - 1][j] = 1; a[i][j] = 0; } else { tmp = a[i][j]; a[i][j] = a[flag][j]; a[flag][j] = tmp; } } } } } //左移 if ((ch1 == 224 &amp;&amp; ch == 75) || (ch == 225 &amp;&amp; ch1 == 163)) { for (i = 1;i &lt;= 4;i++) { for (j = 2;j &lt;= 4;j++) { if (a[i][j] != 0) { flag = j; for (k = j - 1;k &gt;= 1;k--) { if (a[i][k] == 0) flag = k; else break; } /*if (a[i][j] == a[i][j - 1]) { a[i][j- 1] *= 2; a[i][j] = 0; }*/ //交换aij和aiflag; if (a[i][flag - 1] == a[i][j] &amp;&amp; 为了符合规则[i][flag - 1] == 0) { a[i][flag - 1] *= 2; 为了符合规则[i][flag - 1] = 1; a[i][j] = 0; } else { tmp = a[i][j]; a[i][j] = a[i][flag]; a[i][flag] = tmp; } } } } } } for (i = 0;i &lt; 6;i++) { for (j = 0;j &lt; 6;j++) { if (备份[i][j] == a[i][j]) 旗子 = 1; else { 旗子 = 0; break; } } if (旗子 == 0) break; } //空余位置随机生成一个2或者4 int i3, j3, kk; if (旗子 == 0) { do { i3 = rand() % 4 + 1; j3 = rand() % 4 + 1; } while (a[i3][j3] != 0); kk = rand() % 2; if (kk == 1) a[i3][j3] = 2; else a[i3][j3] = 4; } cleardevice(); setcolor(BLACK); setfillcolor(YELLOW); for (i = 100;i &lt; 500;i += 100) { for (j = 100;j &lt; 500;j += 100) { rectangle(i, j, 100 + i, j + 100); fillrectangle(i, j, 100 + i, j + 100); } } //打印a数组 for (i = 1;i &lt; 5;i++) { for (j = 1;j &lt; 5;j++) { if (a[i][j] != 0) { TCHAR s[5]; _stprintf_s(s, _T(&quot;%d&quot;), a[i][j]); /*outtextxy(j * 100 + 25, i * 100 + 25, s);*/ RECT r = { 100 * j, 100 * i, 100 + 100 * j, 100 + 100 * i }; drawtext(s, &amp;r, DT_CENTER | DT_VCENTER | DT_SINGLELINE); } } } FlushBatchDraw(); } return 0;} 3.2048最终版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;#include&lt;conio.h&gt;#include&lt;graphics.h&gt;void 初始化屏幕(){ initgraph(1000, 1000); setbkcolor(WHITE); cleardevice(); int i, j; setcolor(BLACK); setfillcolor(YELLOW); for (i = 100;i &lt; 500;i += 100) { for (j = 100;j &lt; 500;j += 100) { rectangle(i, j, 100 + i, j + 100); fillrectangle(i, j, 100 + i, j + 100); } } settextstyle(30, 20, _T(&quot;隶书&quot;)); setbkmode(TRANSPARENT); /*settextcolor(BLUE);*/ BeginBatchDraw();}void 初始化数组a(int a[6][6],int 备份[6][6]){ int i, j; for (i = 1;i &lt; 5;i++) { for (j = 1;j &lt; 5;j++) { a[i][j] = 0; 备份[i][j] = 0; } } for (i = 0;i &lt; 6;i++) { a[i][0] = 5; a[i][5] = 5; a[0][i] = 5; a[5][i] = 5; } int i1, i2, j1, j2; do { i1 = rand() % 4 + 1; i2 = rand() % 4 + 1; j1 = rand() % 4 + 1; j2 = rand() % 4 + 1; } while (i1 == i2 &amp;&amp; j1 == j2); a[i1][j1] = 2; a[i2][j2] = 2;}void 打印a数组(int a[6][6]){ int i, j; for (i = 1;i &lt; 5;i++) { for (j = 1;j &lt; 5;j++) { if (a[i][j] != 0) { TCHAR s[5]; _stprintf_s(s, _T(&quot;%d&quot;), a[i][j]); /*outtextxy(j * 100 + 25, i * 100 + 25, s);*/ RECT r = { 100 * j, 100 * i, 100 + 100 * j, 100 + 100 * i }; drawtext(s, &amp;r, DT_CENTER | DT_VCENTER | DT_SINGLELINE); } } } FlushBatchDraw();}void 备份并初始化计数器(int a[6][6],int 计数器[6][6], int 备份[6][6]){ int i,j; for (i = 0;i &lt; 6;i++) { for (j = 0;j &lt; 6;j++) { 备份[i][j] = a[i][j]; } } for (i = 0;i &lt; 6;i++) { for (j = 0;j &lt; 6;j++) { 计数器[i][j] = 0; } }}void 键盘控制和游戏规则(int a[6][6],int 计数器[6][6]){ int ch, ch1, flag, tmp = 0,i,j,k; if (_kbhit) { ch1 = _getch(); ch = _getch(); //右移 if ((ch1 == 224 &amp;&amp; ch == 77) || (ch == 228 &amp;&amp; ch1 == 163)) { for (i = 1;i &lt;= 4;i++) { for (j = 3;j &gt;= 1;j--) { if (a[i][j] != 0) { flag = j; for (k = j + 1;k &lt;= 4;k++) { if (a[i][k] == 0) flag = k; else break; } //交换aij和aiflag; if (a[i][flag + 1] == a[i][j] &amp;&amp; 计数器[i][flag + 1] == 0) { a[i][flag + 1] *= 2; a[i][j] = 0; 计数器[i][flag + 1] = 1; } else { tmp = a[i][j]; a[i][j] = a[i][flag]; a[i][flag] = tmp; } } } } } //下移 if ((ch1 == 224 &amp;&amp; ch == 80) || (ch == 243 &amp;&amp; ch1 == 163)) { for (j = 1;j &lt;= 4;j++) { for (i = 3;i &gt;= 1;i--) { if (a[i][j] != 0) { flag = i; for (k = i + 1;k &lt;= 4;k++) { if (a[k][j] == 0) flag = k; else break; } /*if (a[i][j] == a[i][j - 1]) { a[i][j- 1] *= 2; a[i][j] = 0; }*/ //交换aij和aiflag; if (a[flag + 1][j] == a[i][j] &amp;&amp; 计数器[flag + 1][j] == 0) { a[flag + 1][j] *= 2; 计数器[flag + 1][j] = 1; a[i][j] = 0; } else { tmp = a[i][j]; a[i][j] = a[flag][j]; a[flag][j] = tmp; } } } } } //上移 if ((ch1 == 224 &amp;&amp; ch == 72) || (ch == 247 &amp;&amp; ch1 == 163)) { for (j = 1;j &lt;= 4;j++) { for (i = 2;i &lt;= 4;i++) { if (a[i][j] != 0) { flag = i; for (k = i - 1;k &gt;= 1;k--) { if (a[k][j] == 0) flag = k; else break; } /*if (a[i][j] == a[i][j - 1]) { a[i][j- 1] *= 2; a[i][j] = 0; }*/ //交换aij和aiflag; if (a[flag - 1][j] == a[i][j] &amp;&amp; 计数器[flag - 1][j] == 0) { a[flag - 1][j] *= 2; 计数器[flag - 1][j] = 1; a[i][j] = 0; } else { tmp = a[i][j]; a[i][j] = a[flag][j]; a[flag][j] = tmp; } } } } } //左移 if ((ch1 == 224 &amp;&amp; ch == 75) || (ch == 225 &amp;&amp; ch1 == 163)) { for (i = 1;i &lt;= 4;i++) { for (j = 2;j &lt;= 4;j++) { if (a[i][j] != 0) { flag = j; for (k = j - 1;k &gt;= 1;k--) { if (a[i][k] == 0) flag = k; else break; } /*if (a[i][j] == a[i][j - 1]) { a[i][j- 1] *= 2; a[i][j] = 0; }*/ //交换aij和aiflag; if (a[i][flag - 1] == a[i][j] &amp;&amp; 计数器[i][flag - 1] == 0) { a[i][flag - 1] *= 2; 计数器[i][flag - 1] = 1; a[i][j] = 0; } else { tmp = a[i][j]; a[i][j] = a[i][flag]; a[i][flag] = tmp; } } } } } }}int 数据备份并判断有无变化(int a[6][6],int 备份[6][6],int 旗子){ int i, j; for (i = 0;i &lt; 6;i++) { for (j = 0;j &lt; 6;j++) { if (备份[i][j] == a[i][j]) 旗子 = 1; else { 旗子 = 0; break; } } if (旗子 == 0) break; } return 旗子;}void 空余位置随机生成一个2或者4(int a[6][6],int 旗子){ int i3, j3, kk; if (旗子 == 0) { do { i3 = rand() % 4 + 1; j3 = rand() % 4 + 1; } while (a[i3][j3] != 0); kk = rand() % 2; if (kk == 1) a[i3][j3] = 2; else a[i3][j3] = 4; }}void 重新绘制屏幕(){ int i, j; cleardevice(); setcolor(BLACK); setfillcolor(YELLOW); for (i = 100;i &lt; 500;i += 100) { for (j = 100;j &lt; 500;j += 100) { rectangle(i, j, 100 + i, j + 100); fillrectangle(i, j, 100 + i, j + 100); } } FlushBatchDraw();}int main(){ using namespace std; 初始化屏幕(); int a[6][6], 备份[6][6],计数器[6][6], 旗子; srand((int)time(0)); 初始化数组a(a, 备份); 打印a数组(a); while (1) { 旗子 = 1; 备份并初始化计数器(a, 计数器, 备份); 键盘控制和游戏规则(a, 计数器); 旗子 = 数据备份并判断有无变化(a, 备份, 旗子); 空余位置随机生成一个2或者4(a,旗子); 重新绘制屏幕(); 打印a数组(a); } return 0;} 4.2048优化版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;#include&lt;conio.h&gt;#include&lt;graphics.h&gt;#include&lt;cmath&gt;int 判断aij是2的几次方(int tt){ int i, sum = 1, cnt = 0; if (tt == 0) return 0; for (i = 1;;i++) { sum *= 2; cnt++; if (sum == tt) break; } return cnt;}void 初始化屏幕(int a[6][6]){ initgraph(1000, 1000); setbkcolor(WHITE); cleardevice(); int i, j,tt,cnt; setcolor(WHITE); settextcolor(RED); for (i = 1;i &lt; 5;i ++) { for (j = 1;j &lt; 5;j ++) { tt = a[i][j]; cnt=判断aij是2的几次方(tt); setfillcolor(RGB(100, 255, 20 * cnt)); rectangle(j * 100, i * 100, 100 + j * 100, i * 100 + 100); fillrectangle(j*100, i*100, 100 + j*100, i*100 + 100); } } settextstyle(30, 20, _T(&quot;隶书&quot;)); setbkmode(TRANSPARENT); /*settextcolor(BLUE);*/ BeginBatchDraw();}void 初始化数组a(int a[6][6], int 备份[6][6]){ int i, j; for (i = 1;i &lt; 5;i++) { for (j = 1;j &lt; 5;j++) { a[i][j] = 0; 备份[i][j] = 0; } } for (i = 0;i &lt; 6;i++) { a[i][0] = 5; a[i][5] = 5; a[0][i] = 5; a[5][i] = 5; } int i1, i2, j1, j2; do { i1 = rand() % 4 + 1; i2 = rand() % 4 + 1; j1 = rand() % 4 + 1; j2 = rand() % 4 + 1; } while (i1 == i2 &amp;&amp; j1 == j2); a[i1][j1] = 2; a[i2][j2] = 2;}void 打印a数组(int a[6][6]){ int i, j; for (i = 1;i &lt; 5;i++) { for (j = 1;j &lt; 5;j++) { if (a[i][j] != 0) { TCHAR s[5]; _stprintf_s(s, _T(&quot;%d&quot;), a[i][j]); /*outtextxy(j * 100 + 25, i * 100 + 25, s);*/ RECT r = { 100 * j, 100 * i, 100 + 100 * j, 100 + 100 * i }; drawtext(s, &amp;r, DT_CENTER | DT_VCENTER | DT_SINGLELINE); } } } FlushBatchDraw();}void 备份并初始化计数器(int a[6][6], int 计数器[6][6], int 备份[6][6]){ int i, j; for (i = 0;i &lt; 6;i++) { for (j = 0;j &lt; 6;j++) { 备份[i][j] = a[i][j]; } } for (i = 0;i &lt; 6;i++) { for (j = 0;j &lt; 6;j++) { 计数器[i][j] = 0; } }}void 键盘控制和游戏规则(int a[6][6], int 计数器[6][6]){ int ch, ch1, flag, tmp = 0, i, j, k; if (_kbhit) { ch1 = _getch(); ch = _getch(); //右移 if ((ch1 == 224 &amp;&amp; ch == 77) || (ch == 228 &amp;&amp; ch1 == 163)) { for (i = 1;i &lt;= 4;i++) { for (j = 3;j &gt;= 1;j--) { if (a[i][j] != 0) { flag = j; for (k = j + 1;k &lt;= 4;k++) { if (a[i][k] == 0) flag = k; else break; } //交换aij和aiflag; if (a[i][flag + 1] == a[i][j] &amp;&amp; 计数器[i][flag + 1] == 0) { a[i][flag + 1] *= 2; a[i][j] = 0; 计数器[i][flag + 1] = 1; } else { tmp = a[i][j]; a[i][j] = a[i][flag]; a[i][flag] = tmp; } } } } } //下移 if ((ch1 == 224 &amp;&amp; ch == 80) || (ch == 243 &amp;&amp; ch1 == 163)) { for (j = 1;j &lt;= 4;j++) { for (i = 3;i &gt;= 1;i--) { if (a[i][j] != 0) { flag = i; for (k = i + 1;k &lt;= 4;k++) { if (a[k][j] == 0) flag = k; else break; } /*if (a[i][j] == a[i][j - 1]) { a[i][j- 1] *= 2; a[i][j] = 0; }*/ //交换aij和aiflag; if (a[flag + 1][j] == a[i][j] &amp;&amp; 计数器[flag + 1][j] == 0) { a[flag + 1][j] *= 2; 计数器[flag + 1][j] = 1; a[i][j] = 0; } else { tmp = a[i][j]; a[i][j] = a[flag][j]; a[flag][j] = tmp; } } } } } //上移 if ((ch1 == 224 &amp;&amp; ch == 72) || (ch == 247 &amp;&amp; ch1 == 163)) { for (j = 1;j &lt;= 4;j++) { for (i = 2;i &lt;= 4;i++) { if (a[i][j] != 0) { flag = i; for (k = i - 1;k &gt;= 1;k--) { if (a[k][j] == 0) flag = k; else break; } /*if (a[i][j] == a[i][j - 1]) { a[i][j- 1] *= 2; a[i][j] = 0; }*/ //交换aij和aiflag; if (a[flag - 1][j] == a[i][j] &amp;&amp; 计数器[flag - 1][j] == 0) { a[flag - 1][j] *= 2; 计数器[flag - 1][j] = 1; a[i][j] = 0; } else { tmp = a[i][j]; a[i][j] = a[flag][j]; a[flag][j] = tmp; } } } } } //左移 if ((ch1 == 224 &amp;&amp; ch == 75) || (ch == 225 &amp;&amp; ch1 == 163)) { for (i = 1;i &lt;= 4;i++) { for (j = 2;j &lt;= 4;j++) { if (a[i][j] != 0) { flag = j; for (k = j - 1;k &gt;= 1;k--) { if (a[i][k] == 0) flag = k; else break; } /*if (a[i][j] == a[i][j - 1]) { a[i][j- 1] *= 2; a[i][j] = 0; }*/ //交换aij和aiflag; if (a[i][flag - 1] == a[i][j] &amp;&amp; 计数器[i][flag - 1] == 0) { a[i][flag - 1] *= 2; 计数器[i][flag - 1] = 1; a[i][j] = 0; } else { tmp = a[i][j]; a[i][j] = a[i][flag]; a[i][flag] = tmp; } } } } } }}int 数据备份并判断有无变化(int a[6][6], int 备份[6][6], int 旗子){ int i, j; for (i = 0;i &lt; 6;i++) { for (j = 0;j &lt; 6;j++) { if (备份[i][j] == a[i][j]) 旗子 = 1; else { 旗子 = 0; break; } } if (旗子 == 0) break; } return 旗子;}void 空余位置随机生成一个2或者4(int a[6][6], int 旗子){ int i3, j3, kk; if (旗子 == 0) { do { i3 = rand() % 4 + 1; j3 = rand() % 4 + 1; } while (a[i3][j3] != 0); kk = rand() % 2; if (kk == 1) a[i3][j3] = 2; else a[i3][j3] = 4; }}void 重新绘制屏幕(int a[6][6]){ int i, j,tt,cnt; cleardevice(); setcolor(WHITE); settextcolor(RED); for (i = 1;i &lt; 5;i++) { for (j = 1;j &lt; 5;j++) { tt = a[i][j]; cnt = 判断aij是2的几次方(tt); setfillcolor(RGB(100, 255, 20 * cnt)); rectangle(j * 100, i * 100, 100 + j * 100, i * 100 + 100); fillrectangle(j * 100, i * 100, 100 + j * 100, i * 100 + 100); } } FlushBatchDraw();}int main(){ using namespace std; int a[6][6], 备份[6][6], 计数器[6][6], 旗子; srand((int)time(0)); 初始化数组a(a, 备份); 初始化屏幕(a); 打印a数组(a); while (1) { 旗子 = 1; 备份并初始化计数器(a, 计数器, 备份); 键盘控制和游戏规则(a, 计数器); 旗子 = 数据备份并判断有无变化(a, 备份, 旗子); 空余位置随机生成一个2或者4(a, 旗子); 重新绘制屏幕(a); 打印a数组(a); } return 0;} 似乎只改动了颜色","link":"/2021/01/02/2048%E5%B0%8F%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"源码","slug":"源码","link":"/tags/%E6%BA%90%E7%A0%81/"}],"categories":[]}