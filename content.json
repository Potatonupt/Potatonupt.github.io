{"pages":[],"posts":[{"title":"矩阵计算器","text":"线代必备工具 #include#include#include&lt;time.h&gt;#include&lt;graphics.h&gt;#include&lt;conio.h&gt;#include#include#includedouble** 生成矩阵(double** a, int* r, int* c);double 计算行列式(double** a, int n);void 打开菜单();int 执行程序();void 写入文件(double** a, int r1, int c1, double** d, int r2, int c2, std::string name);void 写入逆矩阵(double** a, double** d, int r, std::string name);void 写入行列式(double** a, int r, double ss);void 写入秩(double** a, int r1, int c1, int 秩);void 写入加减法(double** a, int r1, int c1, double** b, double** d, int r, int c, int sign);void 写入乘法(double** a, int r1, int c1, double** b, int r2, int c2, double** d);void 读取文件();void 矩阵转置(double** a, int r, int c);void 矩阵加减法(double** a, double** b, int r1, int c1, int r2, int c2, int sign);void 矩阵数乘(double** a, int r, int c);void 矩阵乘法(double** a, double** b, int r1, int c1, int r2, int c2);int 矩阵化简(double** a, int r, int c, int sign);void 矩阵求逆(double** a, int r);void 打印d数组(double** d, int r, int c);void 打印d数组(double** d, int r);void 内存释放(double** d, int r);int main(){ int 开始; do { 打开菜单(); 开始 = 执行程序(); } while (开始 == 0);}void 矩阵转置(double** a, int r, int c){ double** d = NULL; d = new double* [c]; for (int i = 0; i &lt; c; i++) { d[i] = new double[r]; } for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; c; j++) { d[j][i] = a[i][j]; } } 打印d数组(d, c, r); 写入文件(a, r, c, d, c, r, “的转置为：”); 内存释放(d, c);}void 矩阵加减法(double** a, double** b, int r1, int c1, int r2, int c2, int sign){ if (r1 == r2 &amp;&amp; c1 == c1) { double** d = NULL; d = new double* [r1]; for (int i = 0; i &lt; r1; i++) { d[i] = new double[c1]; } for (int i = 0; i &lt; r1; i++) { for (int j = 0; j &lt; c1; j++) { d[i][j] = a[i][j] + b[i][j] * sign; } } 打印d数组(d, r1, c1); 写入加减法(a, r1, c1, b, d, r1, c1, sign); 内存释放(d, r1); } else printf(“这两个矩阵不可以这样运算！”);}void 矩阵数乘(double** a, int r, int c){ double** d = NULL; d = new double* [r]; for (int i = 0; i &lt; r; i++) { d[i] = new double[c]; } int k; printf(“请输入数值：”); scanf_s(“%d”, &amp;k); for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; c; j++) { d[i][j] = k * a[i][j]; } } 打印d数组(d, r, c); std::to_string(k); std::string name = “数乘” + std::to_string(k) + “的结果为：”; 写入文件(a, r, c, d, r, c, name); 内存释放(d, r);}void 矩阵乘法(double** a, double** b, int r1, int c1, int r2, int c2){ if (r2 == c1) { double** d = NULL, sum; d = new double* [r1]; for (int i = 0; i &lt; r1; i++) { d[i] = new double[c2]; } for (int i = 0; i &lt; r1; i++) { for (int j = 0; j &lt; c2; j++) { sum = 0; for (int k = 0; k &lt; c1; k++) { sum += a[i][k] * b[k][j]; } d[i][j] = sum; } } 打印d数组(d, r1, c2); 写入乘法(a, r1, c1, b, r2, c2, d); 内存释放(d, r1); } else printf(“这两个矩阵不能相乘！”);}int 矩阵化简(double** a, int r, int c, int sign){ double** d; d = new double* [r]; for (int i = 0; i &lt; r; i++) { d[i] = new double[c]; } for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; c; j++) { d[i][j] = a[i][j]; } } //起始行列 int cnt = 0; int cct = 0; int flag; double t; while (cnt &lt;= r &amp;&amp; cct &lt;= c) { flag = -1; for (int i = cnt; i &lt; r; i++) { if (d[i][cct] != 0) { flag = i; break; } } if (flag == -1) { cct++; continue; } //交换两行; if (flag != cnt) { double tmp = 0; for (int j = cct; j &lt; c; j++) { tmp = d[flag][j]; d[flag][j] = d[cnt][j]; d[cnt][j] = tmp; } } //化第一行首个为1 t = d[cnt][cct]; for (int j = cct; j &lt; c; j++) { d[cnt][j] /= t; } for (int i = cnt + 1; i &lt; r; i++) { if (d[i][cct] != 0) { t = d[i][cct]; for (int j = cct; j &lt; c; j++) { d[i][j] = d[i][j] - d[cnt][j] * t; } } } cnt++; cct++; } for (int i = r - 1; i &gt; 0; i–) { flag = -1; for (int j = 0; j &lt; c; j++) { if (d[i][j] != 0) { flag = j; break; } } if (flag != -1) { for (int k = i - 1; k &gt;= 0; k–) { t = d[k][flag]; for (int j = 0; j &lt; c; j++) { d[k][j] = d[k][j] - t * d[i][j]; } } } } int number = 0; for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; c; j++) { if (d[i][j] != 0) { number++; break; } } } if (sign == 0) { 打印d数组(d, r, c); 写入文件(a, r, c, d, r, c, &quot;的化简结果为：&quot;); } else { 打印d数组(d, r); 写入逆矩阵(a, d,r, &quot;的逆矩阵为: &quot;); } 内存释放(d, r); return number; }void 矩阵求逆(double** a, int r){ if (计算行列式(a, r) != 0) { double** d; d = new double* [r]; for (int i = 0; i &lt; r; i++) { d[i] = new double[2 * r]; } for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; r; j++) { d[i][j] = a[i][j]; } for (int j = r; j &lt; 2 * r; j++) { if (i == j - r) d[i][j] = 1; else d[i][j] = 0; } } 矩阵化简(d, r, 2 * r, 1); 内存释放(d, r); } else printf(“这个矩阵不可逆！”); }void 打印d数组(double** d, int r, int c){ printf(“结果如下：\\n”); for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; c; j++) { if ((int)(d[i][j] * 100) % 100 == 0) printf(“%d\\t”, (int)d[i][j]); else printf(“%.2lf\\t”, d[i][j]); } printf(“\\n”); }}void 打印d数组(double** d, int r){ printf(“结果如下：\\n”); for (int i = 0; i &lt; r; i++) { for (int j = r; j &lt; 2 * r; j++) { if ((int)(d[i][j] * 100) % 100 == 0) printf(“%d\\t”, (int)d[i][j]); else printf(“%.2lf\\t”, d[i][j]); } printf(“\\n”); }}double 计算行列式(double** a, int n){ double** d; d = new double* [n]; for (int i = 0; i &lt; n; i++) { d[i] = new double[n]; } for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { d[j][i] = a[i][j]; } } int flag = -1; for (int i = 0; i &lt; n; i++) { if (d[i][0] != 0) { flag = i; break; } } if (flag != 0) { double tmp = 0; for (int j = 0; j &lt; n; j++) { tmp = d[flag][j]; d[flag][j] = d[0][j]; d[0][j] = tmp; } } double tmp; for (int k = 1; k &lt; n; k++) { for (int i = k; i &lt; n; i++) { tmp = d[i][k - 1] / d[k - 1][k - 1]; for (int j = k - 1; j &lt; n; j++) { d[i][j] = d[i][j] - tmp * d[k - 1][j]; } } } double ss = 1; for (int i = 0; i &lt; n; i++) { ss = d[i][i]; } 写入行列式(a, n, ss); 内存释放(d, n); return ss;}double** 生成矩阵(double** a, int r, int* c){ printf(“请输入矩阵的行数，列数：”); scanf_s(“%d%d”, r, c); printf(“请输入矩阵：\\n”); a = new double* [r]; for (int i = 0; i &lt; r; i++) { a[i] = new double[c]; } for (int i = 0; i &lt; *r; i++) { for (int j = 0; j &lt; *c; j++) { scanf_s(“%lf”, &amp;a[i][j]); } } return a;}void 打开菜单(){ printf(“=======================================================================\\n”); printf(“| ———-1|我要求矩阵的加法 ———– |\\n”); printf(“| ———-2|我要求矩阵的减法 ———– |\\n”); printf(“| ———-3|我要求矩阵的转置 ———– |\\n”); printf(“| ———-4|我要求矩阵的逆矩阵———– |\\n”); printf(“| ———-5|我要求最简行矩阵 ———– |\\n”); printf(“| ———-6|我要求矩阵的数乘 ———– |\\n”); printf(“| ———-7|我要求矩阵的乘法 ———– |\\n”); printf(“| ———-8|我要求矩阵的秩 ———– |\\n”); printf(“| ———-9|我要计算行列式的值———– |\\n”); printf(“| ———-0|读取计算结果文件 ———– |\\n”); printf(“| ———-QAQ|输入字母可以退出———– |\\n”); printf(“=======================================================================\\n”);}int 执行程序(){ double a = NULL, ** b = NULL; int r1, c1, r2, c2; char ch; switch (ch = getchar()) { case’1’: { a = 生成矩阵(a, &amp;r1, &amp;c1); b = 生成矩阵(b, &amp;r2, &amp;c2); 矩阵加减法(a, b, r1, c1, r2, c2, 1); 内存释放(a, r1); 内存释放(b, r2); break; } case’2’: { a = 生成矩阵(a, &amp;r1, &amp;c1); b = 生成矩阵(b, &amp;r2, &amp;c2); 矩阵加减法(a, b, r1, c1, r2, c2, -1); 内存释放(a, r1); 内存释放(b, r2); break; } case’3’: { a = 生成矩阵(a, &amp;r1, &amp;c1); 矩阵转置(a, r1, c1); 内存释放(a, r1); break; } case’4’: { a = 生成矩阵(a, &amp;r1, &amp;c1); 矩阵求逆(a, r1); 内存释放(a, r1); break; } case’5’: { a = 生成矩阵(a, &amp;r1, &amp;c1); 矩阵化简(a, r1, c1, 0); 内存释放(a, r1); break; } case’6’: { a = 生成矩阵(a, &amp;r1, &amp;c1); 矩阵数乘(a, r1, c1); 内存释放(a, r1); break; } case’7’: { a = 生成矩阵(a, &amp;r1, &amp;c1); b = 生成矩阵(b, &amp;r2, &amp;c2); 矩阵乘法(a, b, r1, c1, r2, c2); 内存释放(a, r1); 内存释放(b, r2); break; } case’8’: { a = 生成矩阵(a, &amp;r1, &amp;c1); int 秩; 秩 = 矩阵化简(a, r1, c1, 0); printf(“矩阵的秩为：%d\\n”, 秩); 内存释放(a, r1); break; } case’9’: { a = 生成矩阵(a, &amp;r1, &amp;c1); double ss = 计算行列式(a, r1); if ((int)(ss * 100) % 100 == 0) printf(“%d\\t”, (int)ss); else printf(“%.2lf\\t”, ss); 内存释放(a, r1); break; } case ‘0’: { 读取文件(); break; } default: { return -1; } } getchar(); return 0;}void 内存释放(double* d, int r){ for (int i = 0; i &lt; r; i++) { delete[]d[i]; } delete[]d;}void 写入文件(double** a, int r1, int c1, double** d, int r2, int c2,std::string name){ using namespace std; string 文件名; 文件名 = “计算结果.txt”; ofstream fout(文件名.c_str(),ios_base::out|ios_base::app); fout &lt;&lt; “矩阵：” &lt;&lt; endl; for (int i = 0; i &lt; r1; i++) { for (int j = 0; j &lt; c1; j++) { if ((int)(a[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)a[i][j] &lt;&lt; “\\t”; else { fout &lt;&lt; a[i][j] &lt;&lt; “\\t”; } } fout &lt;&lt; endl; } fout &lt;&lt; name &lt;&lt; endl; for (int i = 0; i &lt; r2; i++) { for (int j = 0; j &lt; c2; j++) { if ((int)(d[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)d[i][j] &lt;&lt; “\\t”; else fout &lt;&lt; d[i][j] &lt;&lt; “\\t”; } fout &lt;&lt; endl; } }void 写入逆矩阵(double** a, double** d,int r, std::string name){ using namespace std; string 文件名; 文件名 = “计算结果.txt”; ofstream fout(文件名.c_str(), ios_base::out | ios_base::app); fout &lt;&lt; “矩阵：” &lt;&lt; endl; for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; r; j++) { if ((int)(a[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)a[i][j] &lt;&lt; “\\t”; else { fout &lt;&lt; a[i][j] &lt;&lt; “\\t”; } } fout &lt;&lt; endl; } fout &lt;&lt; name &lt;&lt; endl; for (int i = 0; i &lt; r; i++) { for (int j = r; j &lt; 2*r; j++) { if ((int)(d[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)d[i][j] &lt;&lt; “\\t”; else { fout &lt;&lt; d[i][j] &lt;&lt; “\\t”; } } fout &lt;&lt; endl; } }void 写入行列式(double** a, int r,double ss){ using namespace std; string 文件名; 文件名 = “计算结果.txt”; ofstream fout(文件名.c_str(), ios_base::out | ios_base::app); fout &lt;&lt; “矩阵：” &lt;&lt; endl; for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; r; j++) { if ((int)(a[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)a[i][j] &lt;&lt; “\\t”; else { fout &lt;&lt; a[i][j] &lt;&lt; “\\t”; } } fout &lt;&lt; endl; } fout &lt;&lt; “的行列式的值为：” &lt;&lt; ss &lt;&lt; endl;}void 写入秩(double** a, int r1, int c1, int 秩){ using namespace std; string 文件名; 文件名 = “计算结果.txt”; ofstream fout(文件名.c_str(), ios_base::out | ios_base::app); fout &lt;&lt; “矩阵：” &lt;&lt; endl; for (int i = 0; i &lt; r1; i++) { for (int j = 0; j &lt; 1; j++) { if ((int)(a[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)a[i][j] &lt;&lt; “\\t”; else { fout &lt;&lt; a[i][j] &lt;&lt; “\\t”; } } fout &lt;&lt; endl; } fout &lt;&lt; “的秩为：” &lt;&lt; 秩 &lt;&lt; endl;}void 写入加减法(double** a, int r1, int c1, double** b,double*d,int r,int c, int sign){ using namespace std; string 文件名; 文件名 = “计算结果.txt”; ofstream fout(文件名.c_str(), ios_base::out | ios_base::app); fout &lt;&lt; “矩阵：” &lt;&lt; endl; for (int i = 0; i &lt; r1; i++) { for (int j = 0; j &lt; c1; j++) { if ((int)(a[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)a[i][j] &lt;&lt; “\\t”; else { fout &lt;&lt; a[i][j] &lt;&lt; “\\t”; } } fout &lt;&lt; endl; } if (sign == 1) { fout &lt;&lt; “加矩阵：” &lt;&lt; endl; } else { fout &lt;&lt; “减矩阵：” &lt;&lt; endl; } for (int i = 0; i &lt; r1; i++) { for (int j = 0; j &lt; c1; j++) { if ((int)(b[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)b[i][j] &lt;&lt; “\\t”; else fout &lt;&lt; b[i][j] &lt;&lt; “\\t”; } fout &lt;&lt; endl; } fout &lt;&lt; “的结果为：” &lt;&lt; endl; for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; c; j++) { if ((int)(d[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)d[i][j] &lt;&lt; “\\t”; else fout &lt;&lt; d[i][j] &lt;&lt; “\\t”; } fout &lt;&lt; endl; }}void 写入乘法(double*a,int r1,int c1,doubleb,int r2,int c2,doubled){ using namespace std; string 文件名; 文件名 = “计算结果.txt”; ofstream fout(文件名.c_str(), ios_base::out | ios_base::app); fout &lt;&lt; “矩阵：” &lt;&lt; endl; for (int i = 0; i &lt; r1; i++) { for (int j = 0; j &lt; c1; j++) { if ((int)(a[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)a[i][j] &lt;&lt; “\\t”; else { fout &lt;&lt; a[i][j] &lt;&lt; “\\t”; } } fout &lt;&lt; endl; } fout &lt;&lt; “乘矩阵：” &lt;&lt; endl; for (int i = 0; i &lt; r2; i++) { for (int j = 0; j &lt; c2; j++) { if ((int)(b[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)b[i][j] &lt;&lt; “\\t”; else fout &lt;&lt; b[i][j] &lt;&lt; “\\t”; } fout &lt;&lt; endl; } fout &lt;&lt; “的结果为：” &lt;&lt; endl; for (int i = 0; i &lt; r1; i++) { for (int j = 0; j &lt; c2; j++) { if ((int)(d[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)d[i][j] &lt;&lt; “\\t”; else fout &lt;&lt; d[i][j] &lt;&lt; “\\t”; } fout &lt;&lt; endl; }}void 读取文件(){ using namespace std; char ch; string 文件名; 文件名 = “计算结果.txt”; ifstream fin(文件名); if (fin.is_open()) { while (fin.get(ch)) { cout &lt;&lt; ch; } fin.close(); }}","link":"/2020/12/31/%E7%9F%A9%E9%98%B5%E8%AE%A1%E7%AE%97%E5%99%A8/"}],"tags":[{"name":"源码","slug":"源码","link":"/tags/%E6%BA%90%E7%A0%81/"}],"categories":[]}