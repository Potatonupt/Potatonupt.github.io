{"pages":[],"posts":[{"title":"八王后","text":"百度找的，这个程序相当“好看” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include&lt;iostream&gt;using namespace std;int main(){ int a[9][9]; int x[9]; int n, b = 0; n = 8; for (int i = 0;i &lt; n;i++) { for (int j = 0;j &lt; n;j++) a[i][j] = 0; } for (int c = 1;c &lt;= n;c++) { x[1] = c; a[1][c] = 1; for (int c1 = 1;c1 &lt;= n;c1++) { if (c1 != c) a[1][c1] = 0; } for (int d = 1;d &lt;= n;d++) { x[2] = d; a[2][d] = 1; for (int d1 = 1;d1 &lt;= n;d1++) { if (d1 != d) a[2][d1] = 0; } for (int e = 1;e &lt;= n;e++) { x[3] = e; a[3][e] = 1; for (int e1 = 1;e1 &lt;= n;e1++) { if (e1 != e) a[3][e1] = 0; } for (int f = 1;f &lt;= n;f++) { x[4] = f; a[4][f] = 1; for (int f1 = 1;f1 &lt;= n;f1++) { if (f1 != f) a[4][f1] = 0; } for (int g = 1;g &lt;= n;g++) { x[5] = g; a[5][g] = 1; for (int g1 = 1;g1 &lt;= n;g1++) { if (g1 != g) a[5][g1] = 0; } for (int h = 1;h &lt;= n;h++) { x[6] = h; a[6][h] = 1; for (int h1 = 1;h1 &lt;= n;h1++) { if (h1 != h) a[6][h1] = 0; } for (int i = 1;i &lt;= n;i++) { x[7] = i; a[7][i] = 1; for (int i1 = 1;i1 &lt;= n;i1++) { if (i1 != i) a[7][i1] = 0; } for (int j = 1;j &lt;= n;j++) { x[8] = j; a[8][j] = 1; for (int j1 = 1;j1 &lt;= n;j1++) { if (j1 != j) a[8][j1] = 0; } if (x[1] != x[2] &amp;&amp; x[1] != x[3] &amp;&amp; x[1] != x[4] &amp;&amp; x[1] != x[5] &amp;&amp; x[1] != x[6] &amp;&amp; x[1] != x[7] &amp;&amp; x[1] != x[8]) { if (x[2] != x[3] &amp;&amp; x[2] != x[4] &amp;&amp; x[2] != x[5] &amp;&amp; x[2] != x[6] &amp;&amp; x[2] != x[7] &amp;&amp; x[2] != x[8]) { if (x[3] != x[4] &amp;&amp; x[3] != x[5] &amp;&amp; x[3] != x[6] &amp;&amp; x[3] != x[7] &amp;&amp; x[3] != x[8]) { if (x[4] != x[5] &amp;&amp; x[4] != x[6] &amp;&amp; x[4] != x[7] &amp;&amp; x[4] != x[8]) { if (x[5] != x[6] &amp;&amp; x[5] != x[7] &amp;&amp; x[5] != x[8]) { if (x[6] != x[7] &amp;&amp; x[6] != x[8]) { if (x[7] != x[8]) { if (x[1] != x[2] + 1 &amp;&amp; x[1] != x[3] + 2 &amp;&amp; x[1] != x[4] + 3 &amp;&amp; x[1] != x[5] + 4 &amp;&amp; x[1] != x[6] + 5 &amp;&amp; x[1] != x[7] + 6 &amp;&amp; x[1] != x[8] + 7) { if (x[2] != x[3] + 1 &amp;&amp; x[2] != x[4] + 2 &amp;&amp; x[2] != x[5] + 3 &amp;&amp; x[2] != x[6] + 4 &amp;&amp; x[2] != x[7] + 5 &amp;&amp; x[2] != x[8] + 6) { if (x[3] != x[4] + 1 &amp;&amp; x[3] != x[5] + 2 &amp;&amp; x[3] != x[6] + 3 &amp;&amp; x[3] != x[7] + 4 &amp;&amp; x[3] != x[8] + 5) { if (x[4] != x[5] + 1 &amp;&amp; x[4] != x[6] + 2 &amp;&amp; x[4] != x[7] + 3 &amp;&amp; x[4] != x[8] + 4) { if (x[5] != x[6] + 1 &amp;&amp; x[5] != x[7] + 2 &amp;&amp; x[5] != x[8] + 3) { if (x[6] != x[7] + 1 &amp;&amp; x[6] != x[8] + 2) { if (x[7] != x[8] + 1) { if (x[1] != x[2] - 1 &amp;&amp; x[1] != x[3] - 2 &amp;&amp; x[1] != x[4] - 3 &amp;&amp; x[1] != x[5] - 4 &amp;&amp; x[1] != x[6] - 5 &amp;&amp; x[1] != x[7] - 6 &amp;&amp; x[1] != x[8] - 7) { if (x[2] != x[3] - 1 &amp;&amp; x[2] != x[4] - 2 &amp;&amp; x[2] != x[5] - 3 &amp;&amp; x[2] != x[6] - 4 &amp;&amp; x[2] != x[7] - 5 &amp;&amp; x[2] != x[8] - 6) { if (x[3] != x[4] - 1 &amp;&amp; x[3] != x[5] - 2 &amp;&amp; x[3] != x[6] - 3 &amp;&amp; x[3] != x[7] - 4 &amp;&amp; x[3] != x[8] - 5) { if (x[4] != x[5] - 1 &amp;&amp; x[4] != x[6] - 2 &amp;&amp; x[4] != x[7] - 3 &amp;&amp; x[4] != x[8] - 4) { if (x[5] != x[6] - 1 &amp;&amp; x[5] != x[7] - 2 &amp;&amp; x[5] != x[8] - 3) { if (x[6] != x[7] - 1 &amp;&amp; x[6] != x[8] - 2) { if (x[7] != x[8] - 1) { b++; cout &lt;&lt; &quot;--------&quot; &lt;&lt; b &lt;&lt; &quot;----------&quot; &lt;&lt; endl; for (int k = 1;k &lt;= n;k++) { for (int l = 1;l &lt;= n;l++) cout &lt;&lt; a[k][l] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; } cout &lt;&lt; endl &lt;&lt; endl; } } } } } } } } } } } } } } } } } } } } } } } } } } } } } cout &lt;&lt; &quot;共&quot; &lt;&lt; b &lt;&lt; &quot;种。&quot;; system(&quot;pause&quot;); return 0;}","link":"/2021/01/09/%E5%85%AB%E7%8E%8B%E5%90%8E/"},{"title":"求n个数的最大公约数","text":"这个程序写的太好了！ 123456789#include&lt;stdio.h&gt;int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }int main(){ int n,a,b; scanf_s(&quot;%d%d&quot;, &amp;n, &amp;a); while (--n)scanf_s(&quot;%d&quot;, &amp;b), a = gcd(a, b); printf(&quot;%d&quot;, a);}","link":"/2021/01/05/%E6%B1%82n%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/"},{"title":"链表排序","text":"自己做的一个链表排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#include&lt;cstdlib&gt;#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;using namespace std;typedef struct grade{ string number; string name; int chinese; int math; int english; struct grade* next;}grade;typedef struct point{ grade* head; grade* tail; grade* target1; grade* target2; grade* tmp1; grade* tmp2; grade* now; grade* tt; int cnt;}point;void 读取文件(point* p);void 打印成绩(point* p);void 释放空间(point* p);void 搜索目标(point* p);void 链表排序(point* p);int main(){ point point; 读取文件(&amp;point); 打印成绩(&amp;point); 链表排序(&amp;point); 打印成绩(&amp;point); 释放空间(&amp;point);}void 读取文件(point* p){ ifstream fin(&quot;111.txt&quot;); p-&gt;head = nullptr; p-&gt;tail = nullptr; p-&gt;cnt = 0; grade* now = nullptr; if (fin.is_open()) { while (!fin.eof()) { now = new grade; fin &gt;&gt; now-&gt;number; fin &gt;&gt; now-&gt;name; fin &gt;&gt; now-&gt;chinese; fin &gt;&gt; now-&gt;english; fin &gt;&gt; now-&gt;math; now-&gt;next = nullptr; if (p-&gt;head == nullptr) { p-&gt;head = now; } else { p-&gt;tail-&gt;next = now; } p-&gt;tail = now; (p-&gt;cnt)++; } fin.close(); } else cout &lt;&lt; &quot;打不开文件！&quot;;}void 打印成绩(point* p){ grade* now = p-&gt;head; while (now) { cout &lt;&lt; now-&gt;number &lt;&lt; &quot;\\t&quot;; cout &lt;&lt; now-&gt;name &lt;&lt; &quot;\\t\\t&quot;; cout &lt;&lt; now-&gt;chinese &lt;&lt; &quot;\\t&quot;; cout &lt;&lt; now-&gt;math &lt;&lt; &quot;\\t&quot;; cout &lt;&lt; now-&gt;english &lt;&lt; endl; now = now-&gt;next; } cout &lt;&lt; &quot;共有&quot; &lt;&lt; p-&gt;cnt &lt;&lt; &quot;名学生。\\n&quot;;}void 释放空间(point* p){ grade* now = p-&gt;head, * tmp = nullptr; while (now) { tmp = now; now = now-&gt;next; delete tmp; }}void 链表排序(point* p){ p-&gt;target1 = p-&gt;target2 = p-&gt;head; while (p-&gt;target1) { p-&gt;tmp2 = p-&gt;target1; p-&gt;target2 = p-&gt;target1-&gt;next; p-&gt;tt = p-&gt;target1; 搜索目标(p); if (p-&gt;target2!=p-&gt;target1) { if (p-&gt;target1-&gt;next == p-&gt;target2) { if (p-&gt;target1 == p-&gt;head) { p-&gt;target1-&gt;next = p-&gt;target2-&gt;next; p-&gt;target2-&gt;next = p-&gt;target1; p-&gt;head = p-&gt;target2; } else { p-&gt;tmp1-&gt;next = p-&gt;target2; p-&gt;target1-&gt;next = p-&gt;target2-&gt;next; p-&gt;target2-&gt;next = p-&gt;target1; } } else { if (p-&gt;target1 == p-&gt;head) { p-&gt;target2-&gt;next = p-&gt;target1-&gt;next; p-&gt;target1-&gt;next = p-&gt;now; p-&gt;tmp2-&gt;next = p-&gt;target1; p-&gt;head = p-&gt;target2; } else { p-&gt;target2-&gt;next = p-&gt;target1-&gt;next; p-&gt;tmp1-&gt;next = p-&gt;target2; p-&gt;tmp2-&gt;next = p-&gt;target1; p-&gt;target1-&gt;next = p-&gt;now; } } p-&gt;now = p-&gt;target1; p-&gt;target1 = p-&gt;target2; p-&gt;target2 = p-&gt;now; } p-&gt;tmp1 = p-&gt;target1; p-&gt;target1 = p-&gt;target1-&gt;next; }}void 搜索目标(point* p){ while (p-&gt;target2) { if (p-&gt;tt-&gt;chinese &lt; p-&gt;target2-&gt;chinese) { p-&gt;now = p-&gt;tmp2; p-&gt;tt = p-&gt;target2; } p-&gt;tmp2 = p-&gt;tmp2-&gt;next; p-&gt;target2 = p-&gt;target2-&gt;next; } p-&gt;target2 = p-&gt;tt; p-&gt;tmp2 = p-&gt;now; p-&gt;now = p-&gt;target2-&gt;next;}","link":"/2021/01/09/%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F/"},{"title":"矩阵计算器","text":"线代必备工具 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;time.h&gt;#include&lt;graphics.h&gt;#include&lt;conio.h&gt;#include&lt;fstream&gt;#include&lt;string&gt;#include&lt;iostream&gt;double** 生成矩阵(double** a, int* r, int* c);double 计算行列式(double** a, int n);void 打开菜单();int 执行程序();void 写入文件(double** a, int r1, int c1, double** d, int r2, int c2, std::string name);void 写入逆矩阵(double** a, double** d, int r, std::string name);void 写入行列式(double** a, int r, double ss);void 写入秩(double** a, int r1, int c1, int 秩);void 写入加减法(double** a, int r1, int c1, double** b, double** d, int r, int c, int sign);void 写入乘法(double** a, int r1, int c1, double** b, int r2, int c2, double** d);void 读取文件();void 矩阵转置(double** a, int r, int c);void 矩阵加减法(double** a, double** b, int r1, int c1, int r2, int c2, int sign);void 矩阵数乘(double** a, int r, int c);void 矩阵乘法(double** a, double** b, int r1, int c1, int r2, int c2);int 矩阵化简(double** a, int r, int c, int sign);void 矩阵求逆(double** a, int r);void 打印d数组(double** d, int r, int c);void 打印d数组(double** d, int r);void 内存释放(double** d, int r);int main(){ int 开始; do { 打开菜单(); 开始 = 执行程序(); } while (开始 == 0);}void 矩阵转置(double** a, int r, int c){ double** d = NULL; d = new double* [c]; for (int i = 0; i &lt; c; i++) { d[i] = new double[r]; } for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; c; j++) { d[j][i] = a[i][j]; } } 打印d数组(d, c, r); 写入文件(a, r, c, d, c, r, &quot;的转置为：&quot;); 内存释放(d, c);}void 矩阵加减法(double** a, double** b, int r1, int c1, int r2, int c2, int sign){ if (r1 == r2 &amp;&amp; c1 == c1) { double** d = NULL; d = new double* [r1]; for (int i = 0; i &lt; r1; i++) { d[i] = new double[c1]; } for (int i = 0; i &lt; r1; i++) { for (int j = 0; j &lt; c1; j++) { d[i][j] = a[i][j] + b[i][j] * sign; } } 打印d数组(d, r1, c1); 写入加减法(a, r1, c1, b, d, r1, c1, sign); 内存释放(d, r1); } else printf(&quot;这两个矩阵不可以这样运算！&quot;);}void 矩阵数乘(double** a, int r, int c){ double** d = NULL; d = new double* [r]; for (int i = 0; i &lt; r; i++) { d[i] = new double[c]; } int k; printf(&quot;请输入数值：&quot;); scanf_s(&quot;%d&quot;, &amp;k); for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; c; j++) { d[i][j] = k * a[i][j]; } } 打印d数组(d, r, c); std::to_string(k); std::string name = &quot;数乘&quot; + std::to_string(k) + &quot;的结果为：&quot;; 写入文件(a, r, c, d, r, c, name); 内存释放(d, r);}void 矩阵乘法(double** a, double** b, int r1, int c1, int r2, int c2){ if (r2 == c1) { double** d = NULL, sum; d = new double* [r1]; for (int i = 0; i &lt; r1; i++) { d[i] = new double[c2]; } for (int i = 0; i &lt; r1; i++) { for (int j = 0; j &lt; c2; j++) { sum = 0; for (int k = 0; k &lt; c1; k++) { sum += a[i][k] * b[k][j]; } d[i][j] = sum; } } 打印d数组(d, r1, c2); 写入乘法(a, r1, c1, b, r2, c2, d); 内存释放(d, r1); } else printf(&quot;这两个矩阵不能相乘！&quot;);}int 矩阵化简(double** a, int r, int c, int sign){ double** d; d = new double* [r]; for (int i = 0; i &lt; r; i++) { d[i] = new double[c]; } for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; c; j++) { d[i][j] = a[i][j]; } } //起始行列 int cnt = 0; int cct = 0; int flag; double t; while (cnt &lt;= r &amp;&amp; cct &lt;= c) { flag = -1; for (int i = cnt; i &lt; r; i++) { if (d[i][cct] != 0) { flag = i; break; } } if (flag == -1) { cct++; continue; } //交换两行; if (flag != cnt) { double tmp = 0; for (int j = cct; j &lt; c; j++) { tmp = d[flag][j]; d[flag][j] = d[cnt][j]; d[cnt][j] = tmp; } } //化第一行首个为1 t = d[cnt][cct]; for (int j = cct; j &lt; c; j++) { d[cnt][j] /= t; } for (int i = cnt + 1; i &lt; r; i++) { if (d[i][cct] != 0) { t = d[i][cct]; for (int j = cct; j &lt; c; j++) { d[i][j] = d[i][j] - d[cnt][j] * t; } } } cnt++; cct++; } for (int i = r - 1; i &gt; 0; i--) { flag = -1; for (int j = 0; j &lt; c; j++) { if (d[i][j] != 0) { flag = j; break; } } if (flag != -1) { for (int k = i - 1; k &gt;= 0; k--) { t = d[k][flag]; for (int j = 0; j &lt; c; j++) { d[k][j] = d[k][j] - t * d[i][j]; } } } } int number = 0; for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; c; j++) { if (d[i][j] != 0) { number++; break; } } } if (sign == 0) { 打印d数组(d, r, c); 写入文件(a, r, c, d, r, c, &quot;的化简结果为：&quot;); } else { 打印d数组(d, r); 写入逆矩阵(a, d,r, &quot;的逆矩阵为: &quot;); } 内存释放(d, r); return number;}void 矩阵求逆(double** a, int r){ if (计算行列式(a, r) != 0) { double** d; d = new double* [r]; for (int i = 0; i &lt; r; i++) { d[i] = new double[2 * r]; } for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; r; j++) { d[i][j] = a[i][j]; } for (int j = r; j &lt; 2 * r; j++) { if (i == j - r) d[i][j] = 1; else d[i][j] = 0; } } 矩阵化简(d, r, 2 * r, 1); 内存释放(d, r); } else printf(&quot;这个矩阵不可逆！&quot;);}void 打印d数组(double** d, int r, int c){ printf(&quot;结果如下：\\n&quot;); for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; c; j++) { if ((int)(d[i][j] * 100) % 100 == 0) printf(&quot;%d\\t&quot;, (int)d[i][j]); else printf(&quot;%.2lf\\t&quot;, d[i][j]); } printf(&quot;\\n&quot;); }}void 打印d数组(double** d, int r){ printf(&quot;结果如下：\\n&quot;); for (int i = 0; i &lt; r; i++) { for (int j = r; j &lt; 2 * r; j++) { if ((int)(d[i][j] * 100) % 100 == 0) printf(&quot;%d\\t&quot;, (int)d[i][j]); else printf(&quot;%.2lf\\t&quot;, d[i][j]); } printf(&quot;\\n&quot;); }}double 计算行列式(double** a, int n){ double** d; d = new double* [n]; for (int i = 0; i &lt; n; i++) { d[i] = new double[n]; } for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { d[j][i] = a[i][j]; } } int flag = -1; for (int i = 0; i &lt; n; i++) { if (d[i][0] != 0) { flag = i; break; } } if (flag != 0) { double tmp = 0; for (int j = 0; j &lt; n; j++) { tmp = d[flag][j]; d[flag][j] = d[0][j]; d[0][j] = tmp; } } double tmp; for (int k = 1; k &lt; n; k++) { for (int i = k; i &lt; n; i++) { tmp = d[i][k - 1] / d[k - 1][k - 1]; for (int j = k - 1; j &lt; n; j++) { d[i][j] = d[i][j] - tmp * d[k - 1][j]; } } } double ss = 1; for (int i = 0; i &lt; n; i++) { ss *= d[i][i]; } 写入行列式(a, n, ss); 内存释放(d, n); return ss;}double** 生成矩阵(double** a, int* r, int* c){ printf(&quot;请输入矩阵的行数，列数：&quot;); scanf_s(&quot;%d%d&quot;, r, c); printf(&quot;请输入矩阵：\\n&quot;); a = new double* [*r]; for (int i = 0; i &lt; *r; i++) { a[i] = new double[*c]; } for (int i = 0; i &lt; *r; i++) { for (int j = 0; j &lt; *c; j++) { scanf_s(&quot;%lf&quot;, &amp;a[i][j]); } } return a;}void 打开菜单(){ printf(&quot;=======================================================================\\n&quot;); printf(&quot;| ----------1|我要求矩阵的加法 ----------- |\\n&quot;); printf(&quot;| ----------2|我要求矩阵的减法 ----------- |\\n&quot;); printf(&quot;| ----------3|我要求矩阵的转置 ----------- |\\n&quot;); printf(&quot;| ----------4|我要求矩阵的逆矩阵----------- |\\n&quot;); printf(&quot;| ----------5|我要求最简行矩阵 ----------- |\\n&quot;); printf(&quot;| ----------6|我要求矩阵的数乘 ----------- |\\n&quot;); printf(&quot;| ----------7|我要求矩阵的乘法 ----------- |\\n&quot;); printf(&quot;| ----------8|我要求矩阵的秩 ----------- |\\n&quot;); printf(&quot;| ----------9|我要计算行列式的值----------- |\\n&quot;); printf(&quot;| ----------0|读取计算结果文件 ----------- |\\n&quot;); printf(&quot;| ----------QAQ|输入字母可以退出----------- |\\n&quot;); printf(&quot;=======================================================================\\n&quot;);}int 执行程序(){ double** a = NULL, ** b = NULL; int r1, c1, r2, c2; char ch; switch (ch = getchar()) { case'1': { a = 生成矩阵(a, &amp;r1, &amp;c1); b = 生成矩阵(b, &amp;r2, &amp;c2); 矩阵加减法(a, b, r1, c1, r2, c2, 1); 内存释放(a, r1); 内存释放(b, r2); break; } case'2': { a = 生成矩阵(a, &amp;r1, &amp;c1); b = 生成矩阵(b, &amp;r2, &amp;c2); 矩阵加减法(a, b, r1, c1, r2, c2, -1); 内存释放(a, r1); 内存释放(b, r2); break; } case'3': { a = 生成矩阵(a, &amp;r1, &amp;c1); 矩阵转置(a, r1, c1); 内存释放(a, r1); break; } case'4': { a = 生成矩阵(a, &amp;r1, &amp;c1); 矩阵求逆(a, r1); 内存释放(a, r1); break; } case'5': { a = 生成矩阵(a, &amp;r1, &amp;c1); 矩阵化简(a, r1, c1, 0); 内存释放(a, r1); break; } case'6': { a = 生成矩阵(a, &amp;r1, &amp;c1); 矩阵数乘(a, r1, c1); 内存释放(a, r1); break; } case'7': { a = 生成矩阵(a, &amp;r1, &amp;c1); b = 生成矩阵(b, &amp;r2, &amp;c2); 矩阵乘法(a, b, r1, c1, r2, c2); 内存释放(a, r1); 内存释放(b, r2); break; } case'8': { a = 生成矩阵(a, &amp;r1, &amp;c1); int 秩; 秩 = 矩阵化简(a, r1, c1, 0); printf(&quot;矩阵的秩为：%d\\n&quot;, 秩); 内存释放(a, r1); break; } case'9': { a = 生成矩阵(a, &amp;r1, &amp;c1); double ss = 计算行列式(a, r1); if ((int)(ss * 100) % 100 == 0) printf(&quot;%d\\t&quot;, (int)ss); else printf(&quot;%.2lf\\t&quot;, ss); 内存释放(a, r1); break; } case '0': { 读取文件(); break; } default: { return -1; } } getchar(); return 0;}void 内存释放(double** d, int r){ for (int i = 0; i &lt; r; i++) { delete[]d[i]; } delete[]d;}void 写入文件(double** a, int r1, int c1, double** d, int r2, int c2,std::string name){ using namespace std; string 文件名; 文件名 = &quot;计算结果.txt&quot;; ofstream fout(文件名.c_str(),ios_base::out|ios_base::app); fout &lt;&lt; &quot;矩阵：&quot; &lt;&lt; endl; for (int i = 0; i &lt; r1; i++) { for (int j = 0; j &lt; c1; j++) { if ((int)(a[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)a[i][j] &lt;&lt; &quot;\\t&quot;; else { fout &lt;&lt; a[i][j] &lt;&lt; &quot;\\t&quot;; } } fout &lt;&lt; endl; } fout &lt;&lt; name &lt;&lt; endl; for (int i = 0; i &lt; r2; i++) { for (int j = 0; j &lt; c2; j++) { if ((int)(d[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)d[i][j] &lt;&lt; &quot;\\t&quot;; else fout &lt;&lt; d[i][j] &lt;&lt; &quot;\\t&quot;; } fout &lt;&lt; endl; }}void 写入逆矩阵(double** a, double** d,int r, std::string name){ using namespace std; string 文件名; 文件名 = &quot;计算结果.txt&quot;; ofstream fout(文件名.c_str(), ios_base::out | ios_base::app); fout &lt;&lt; &quot;矩阵：&quot; &lt;&lt; endl; for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; r; j++) { if ((int)(a[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)a[i][j] &lt;&lt; &quot;\\t&quot;; else { fout &lt;&lt; a[i][j] &lt;&lt; &quot;\\t&quot;; } } fout &lt;&lt; endl; } fout &lt;&lt; name &lt;&lt; endl; for (int i = 0; i &lt; r; i++) { for (int j = r; j &lt; 2*r; j++) { if ((int)(d[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)d[i][j] &lt;&lt; &quot;\\t&quot;; else { fout &lt;&lt; d[i][j] &lt;&lt; &quot;\\t&quot;; } } fout &lt;&lt; endl; }}void 写入行列式(double** a, int r,double ss){ using namespace std; string 文件名; 文件名 = &quot;计算结果.txt&quot;; ofstream fout(文件名.c_str(), ios_base::out | ios_base::app); fout &lt;&lt; &quot;矩阵：&quot; &lt;&lt; endl; for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; r; j++) { if ((int)(a[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)a[i][j] &lt;&lt; &quot;\\t&quot;; else { fout &lt;&lt; a[i][j] &lt;&lt; &quot;\\t&quot;; } } fout &lt;&lt; endl; } fout &lt;&lt; &quot;的行列式的值为：&quot; &lt;&lt; ss &lt;&lt; endl;}void 写入秩(double** a, int r1, int c1, int 秩){ using namespace std; string 文件名; 文件名 = &quot;计算结果.txt&quot;; ofstream fout(文件名.c_str(), ios_base::out | ios_base::app); fout &lt;&lt; &quot;矩阵：&quot; &lt;&lt; endl; for (int i = 0; i &lt; r1; i++) { for (int j = 0; j &lt; 1; j++) { if ((int)(a[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)a[i][j] &lt;&lt; &quot;\\t&quot;; else { fout &lt;&lt; a[i][j] &lt;&lt; &quot;\\t&quot;; } } fout &lt;&lt; endl; } fout &lt;&lt; &quot;的秩为：&quot; &lt;&lt; 秩 &lt;&lt; endl;}void 写入加减法(double** a, int r1, int c1, double** b,double**d,int r,int c, int sign){ using namespace std; string 文件名; 文件名 = &quot;计算结果.txt&quot;; ofstream fout(文件名.c_str(), ios_base::out | ios_base::app); fout &lt;&lt; &quot;矩阵：&quot; &lt;&lt; endl; for (int i = 0; i &lt; r1; i++) { for (int j = 0; j &lt; c1; j++) { if ((int)(a[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)a[i][j] &lt;&lt; &quot;\\t&quot;; else { fout &lt;&lt; a[i][j] &lt;&lt; &quot;\\t&quot;; } } fout &lt;&lt; endl; } if (sign == 1) { fout &lt;&lt; &quot;加矩阵：&quot; &lt;&lt; endl; } else { fout &lt;&lt; &quot;减矩阵：&quot; &lt;&lt; endl; } for (int i = 0; i &lt; r1; i++) { for (int j = 0; j &lt; c1; j++) { if ((int)(b[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)b[i][j] &lt;&lt; &quot;\\t&quot;; else fout &lt;&lt; b[i][j] &lt;&lt; &quot;\\t&quot;; } fout &lt;&lt; endl; } fout &lt;&lt; &quot;的结果为：&quot; &lt;&lt; endl; for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; c; j++) { if ((int)(d[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)d[i][j] &lt;&lt; &quot;\\t&quot;; else fout &lt;&lt; d[i][j] &lt;&lt; &quot;\\t&quot;; } fout &lt;&lt; endl; }}void 写入乘法(double**a,int r1,int c1,double**b,int r2,int c2,double**d){ using namespace std; string 文件名; 文件名 = &quot;计算结果.txt&quot;; ofstream fout(文件名.c_str(), ios_base::out | ios_base::app); fout &lt;&lt; &quot;矩阵：&quot; &lt;&lt; endl; for (int i = 0; i &lt; r1; i++) { for (int j = 0; j &lt; c1; j++) { if ((int)(a[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)a[i][j] &lt;&lt; &quot;\\t&quot;; else { fout &lt;&lt; a[i][j] &lt;&lt; &quot;\\t&quot;; } } fout &lt;&lt; endl; } fout &lt;&lt; &quot;乘矩阵：&quot; &lt;&lt; endl; for (int i = 0; i &lt; r2; i++) { for (int j = 0; j &lt; c2; j++) { if ((int)(b[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)b[i][j] &lt;&lt; &quot;\\t&quot;; else fout &lt;&lt; b[i][j] &lt;&lt; &quot;\\t&quot;; } fout &lt;&lt; endl; } fout &lt;&lt; &quot;的结果为：&quot; &lt;&lt; endl; for (int i = 0; i &lt; r1; i++) { for (int j = 0; j &lt; c2; j++) { if ((int)(d[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)d[i][j] &lt;&lt; &quot;\\t&quot;; else fout &lt;&lt; d[i][j] &lt;&lt; &quot;\\t&quot;; } fout &lt;&lt; endl; }}void 读取文件(){ using namespace std; char ch; string 文件名; 文件名 = &quot;计算结果.txt&quot;; ifstream fin(文件名); if (fin.is_open()) { while (fin.get(ch)) { cout &lt;&lt; ch; } fin.close(); }}","link":"/2020/12/31/%E7%9F%A9%E9%98%B5%E8%AE%A1%E7%AE%97%E5%99%A8/"},{"title":"2048小游戏","text":"基于easyx，这是我做的第一个游戏 1.2048字符版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;#include&lt;conio.h&gt;#include&lt;graphics.h&gt;int main(){ using namespace std; int a[6][6], 备份[6][6]; int i, j, k; srand((int)time(0)); //初始化数组a,并且随机产生两个2 for (i = 1;i &lt; 5;i++) { for (j = 1;j &lt; 5;j++) { a[i][j] = 0; 备份[i][j] = 0; } } for (i = 0;i &lt; 6;i++) { a[i][0] = 5; a[i][5] = 5; a[0][i] = 5; a[5][i] = 5; } int i1, i2, j1, j2; do { i1 = rand() % 4 + 1; i2 = rand() % 4 + 1; j1 = rand() % 4 + 1; j2 = rand() % 4 + 1; } while (i1 == i2 &amp;&amp; j1 == j2); a[i1][j1] = 2; a[i2][j2] = 2; //打印初始数组 for (i = 1;i &lt; 5;i++) { for (j = 1;j &lt; 5;j++) { cout &lt;&lt; a[i][j]&lt;&lt;&quot;\\t&quot;; } cout &lt;&lt; endl; } cout &lt;&lt; endl; //键盘输入，后，随机一个格子生成一个数字 int ch, ch1, flag, tmp = 0, 为了符合规则[6][6];// 4 4 2 2 动过的不再动 while (1) { for (i = 0;i &lt; 6;i++) { for (j = 0;j &lt; 6;j++) { 为了符合规则[i][j] = 0; } } if (_kbhit) { ch1 = _getch(); ch = _getch(); //右移 if ((ch1 == 224 &amp;&amp; ch == 77) || (ch == 228 &amp;&amp; ch1 == 163)) { for (i = 1;i &lt;= 4;i++) { for (j = 3;j &gt;= 1;j--) { if (a[i][j] != 0) { flag = j; for (k = j + 1;k &lt;= 4;k++) { if (a[i][k] == 0) flag = k; else break; } //交换aij和aiflag; if (a[i][flag + 1] == a[i][j]&amp;&amp;为了符合规则[i][flag+1]==0) { a[i][flag + 1] *= 2; a[i][j] = 0; 为了符合规则[i][flag + 1] = 1; } else { tmp = a[i][j]; a[i][j] = a[i][flag]; a[i][flag] = tmp; } } } } } //下移 if ((ch1 == 224 &amp;&amp; ch == 80) || (ch == 243 &amp;&amp; ch1 == 163)) { for (j = 1;j &lt;= 4;j++) { for (i = 3;i &gt;= 1;i--) { if (a[i][j] != 0) { flag = i; for (k = i + 1;k &lt;=4;k++) { if (a[k][j] == 0) flag = k; else break; } /*if (a[i][j] == a[i][j - 1]) { a[i][j- 1] *= 2; a[i][j] = 0; }*/ //交换aij和aiflag; if (a[flag + 1][j] == a[i][j] &amp;&amp; 为了符合规则[flag + 1][j] == 0) { a[flag + 1][j] *= 2; 为了符合规则[flag + 1][j] = 1; a[i][j] = 0; } else { tmp = a[i][j]; a[i][j] = a[flag][j]; a[flag][j] = tmp; } } } } } //上移 if ((ch1 == 224 &amp;&amp; ch == 72) || (ch == 247 &amp;&amp; ch1 == 163)) { for (j = 1;j &lt;= 4;j++) { for (i = 2;i &lt;= 4;i++) { if (a[i][j] != 0) { flag = i; for (k = i - 1;k &gt;= 1;k--) { if (a[k][j] == 0) flag = k; else break; } /*if (a[i][j] == a[i][j - 1]) { a[i][j- 1] *= 2; a[i][j] = 0; }*/ //交换aij和aiflag; if (a[flag - 1][j] == a[i][j] &amp;&amp; 为了符合规则[flag - 1][j] == 0) { a[flag - 1][j] *= 2; 为了符合规则[flag - 1][j] = 1; a[i][j] = 0; } else { tmp = a[i][j]; a[i][j] = a[flag][j]; a[flag][j] = tmp; } } } } } //左移 if ((ch1 == 224 &amp;&amp; ch == 75) || (ch == 225 &amp;&amp; ch1 == 163)) { for (i = 1;i &lt;= 4;i++) { for (j = 2;j &lt;= 4;j++) { if (a[i][j] != 0) { flag = j; for (k = j - 1;k &gt;= 1;k--) { if (a[i][k] == 0) flag = k; else break; } /*if (a[i][j] == a[i][j - 1]) { a[i][j- 1] *= 2; a[i][j] = 0; }*/ //交换aij和aiflag; if (a[i][flag - 1] == a[i][j] &amp;&amp; 为了符合规则[i][flag - 1] == 0) { a[i][flag - 1] *= 2; 为了符合规则[i][flag - 1] = 1; a[i][j] = 0; } else { tmp = a[i][j]; a[i][j] = a[i][flag]; a[i][flag] = tmp; } } } } } } //空余位置随机生成一个2或者4 int i3, j3, kk; do { i3 = rand() % 4 + 1; j3 = rand() % 4 + 1; } while (a[i3][j3] != 0); kk = rand() % 2; if (kk == 1) a[i3][j3] = 2; else a[i3][j3] = 4; //打印a数组 for (i = 1;i &lt; 5;i++) { for (j = 1;j &lt; 5;j++) { cout &lt;&lt; a[i][j] &lt;&lt; &quot;\\t&quot;; } cout &lt;&lt; endl; } cout &lt;&lt; endl; }} 2.2048图像版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;#include&lt;conio.h&gt;#include&lt;graphics.h&gt;void 初始化屏幕(){ initgraph(1000, 1000); setbkcolor(WHITE); cleardevice(); int i, j; setcolor(BLACK); setfillcolor(YELLOW); for (i = 100;i &lt; 500;i+=100) { for (j = 100;j &lt; 500;j+=100) { rectangle(i, j, 100+i, j+100); fillrectangle(i, j, 100 + i, j + 100); } } settextstyle(25, 25, _T(&quot;隶书&quot;)); setbkmode(TRANSPARENT); BeginBatchDraw();}int main(){ using namespace std; 初始化屏幕(); int a[6][6], 备份[6][6]; int i, j, k; srand((int)time(0)); //初始化数组a,并且随机产生两个2 for (i = 1;i &lt; 5;i++) { for (j = 1;j &lt; 5;j++) { a[i][j] = 0; 备份[i][j] = 0; } } for (i = 0;i &lt; 6;i++) { a[i][0] = 5; a[i][5] = 5; a[0][i] = 5; a[5][i] = 5; } int i1, i2, j1, j2; do { i1 = rand() % 4 + 1; i2 = rand() % 4 + 1; j1 = rand() % 4 + 1; j2 = rand() % 4 + 1; } while (i1 == i2 &amp;&amp; j1 == j2); a[i1][j1] = 2; a[i2][j2] = 2; //打印初始数组 for (i = 1;i &lt; 5;i++) { for (j = 1;j &lt; 5;j++) { if (a[i][j] != 0) { TCHAR s[5]; _stprintf_s(s, _T(&quot;%d&quot;), a[i][j]); /*outtextxy(j * 100 + 25, i * 100 + 25, s);*/ RECT r = { 100 * j, 100 * i, 100 + 100 * j, 100 + 100 * i }; drawtext(s, &amp;r, DT_CENTER | DT_VCENTER | DT_SINGLELINE); } } } FlushBatchDraw(); //键盘输入，后，随机一个格子生成一个数字 int ch, ch1, flag, tmp = 0, 为了符合规则[6][6],旗子;// 4 4 2 2 动过的不再动 while (1) { 旗子 = 1; for (i = 0;i &lt; 6;i++) { for (j = 0;j &lt; 6;j++) { 备份[i][j] = a[i][j]; } } for (i = 0;i &lt; 6;i++) { for (j = 0;j &lt; 6;j++) { 为了符合规则[i][j] = 0; } } if (_kbhit) { ch1 = _getch(); ch = _getch(); //右移 if ((ch1 == 224 &amp;&amp; ch == 77) || (ch == 228 &amp;&amp; ch1 == 163)) { for (i = 1;i &lt;= 4;i++) { for (j = 3;j &gt;= 1;j--) { if (a[i][j] != 0) { flag = j; for (k = j + 1;k &lt;= 4;k++) { if (a[i][k] == 0) flag = k; else break; } //交换aij和aiflag; if (a[i][flag + 1] == a[i][j] &amp;&amp; 为了符合规则[i][flag + 1] == 0) { a[i][flag + 1] *= 2; a[i][j] = 0; 为了符合规则[i][flag + 1] = 1; } else { tmp = a[i][j]; a[i][j] = a[i][flag]; a[i][flag] = tmp; } } } } } //下移 if ((ch1 == 224 &amp;&amp; ch == 80) || (ch == 243 &amp;&amp; ch1 == 163)) { for (j = 1;j &lt;= 4;j++) { for (i = 3;i &gt;= 1;i--) { if (a[i][j] != 0) { flag = i; for (k = i + 1;k &lt;= 4;k++) { if (a[k][j] == 0) flag = k; else break; } /*if (a[i][j] == a[i][j - 1]) { a[i][j- 1] *= 2; a[i][j] = 0; }*/ //交换aij和aiflag; if (a[flag + 1][j] == a[i][j] &amp;&amp; 为了符合规则[flag + 1][j] == 0) { a[flag + 1][j] *= 2; 为了符合规则[flag + 1][j] = 1; a[i][j] = 0; } else { tmp = a[i][j]; a[i][j] = a[flag][j]; a[flag][j] = tmp; } } } } } //上移 if ((ch1 == 224 &amp;&amp; ch == 72) || (ch == 247 &amp;&amp; ch1 == 163)) { for (j = 1;j &lt;= 4;j++) { for (i = 2;i &lt;= 4;i++) { if (a[i][j] != 0) { flag = i; for (k = i - 1;k &gt;= 1;k--) { if (a[k][j] == 0) flag = k; else break; } /*if (a[i][j] == a[i][j - 1]) { a[i][j- 1] *= 2; a[i][j] = 0; }*/ //交换aij和aiflag; if (a[flag - 1][j] == a[i][j] &amp;&amp; 为了符合规则[flag - 1][j] == 0) { a[flag - 1][j] *= 2; 为了符合规则[flag - 1][j] = 1; a[i][j] = 0; } else { tmp = a[i][j]; a[i][j] = a[flag][j]; a[flag][j] = tmp; } } } } } //左移 if ((ch1 == 224 &amp;&amp; ch == 75) || (ch == 225 &amp;&amp; ch1 == 163)) { for (i = 1;i &lt;= 4;i++) { for (j = 2;j &lt;= 4;j++) { if (a[i][j] != 0) { flag = j; for (k = j - 1;k &gt;= 1;k--) { if (a[i][k] == 0) flag = k; else break; } /*if (a[i][j] == a[i][j - 1]) { a[i][j- 1] *= 2; a[i][j] = 0; }*/ //交换aij和aiflag; if (a[i][flag - 1] == a[i][j] &amp;&amp; 为了符合规则[i][flag - 1] == 0) { a[i][flag - 1] *= 2; 为了符合规则[i][flag - 1] = 1; a[i][j] = 0; } else { tmp = a[i][j]; a[i][j] = a[i][flag]; a[i][flag] = tmp; } } } } } } for (i = 0;i &lt; 6;i++) { for (j = 0;j &lt; 6;j++) { if (备份[i][j] == a[i][j]) 旗子 = 1; else { 旗子 = 0; break; } } if (旗子 == 0) break; } //空余位置随机生成一个2或者4 int i3, j3, kk; if (旗子 == 0) { do { i3 = rand() % 4 + 1; j3 = rand() % 4 + 1; } while (a[i3][j3] != 0); kk = rand() % 2; if (kk == 1) a[i3][j3] = 2; else a[i3][j3] = 4; } cleardevice(); setcolor(BLACK); setfillcolor(YELLOW); for (i = 100;i &lt; 500;i += 100) { for (j = 100;j &lt; 500;j += 100) { rectangle(i, j, 100 + i, j + 100); fillrectangle(i, j, 100 + i, j + 100); } } //打印a数组 for (i = 1;i &lt; 5;i++) { for (j = 1;j &lt; 5;j++) { if (a[i][j] != 0) { TCHAR s[5]; _stprintf_s(s, _T(&quot;%d&quot;), a[i][j]); /*outtextxy(j * 100 + 25, i * 100 + 25, s);*/ RECT r = { 100 * j, 100 * i, 100 + 100 * j, 100 + 100 * i }; drawtext(s, &amp;r, DT_CENTER | DT_VCENTER | DT_SINGLELINE); } } } FlushBatchDraw(); } return 0;} 3.2048最终版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;#include&lt;conio.h&gt;#include&lt;graphics.h&gt;void 初始化屏幕(){ initgraph(1000, 1000); setbkcolor(WHITE); cleardevice(); int i, j; setcolor(BLACK); setfillcolor(YELLOW); for (i = 100;i &lt; 500;i += 100) { for (j = 100;j &lt; 500;j += 100) { rectangle(i, j, 100 + i, j + 100); fillrectangle(i, j, 100 + i, j + 100); } } settextstyle(30, 20, _T(&quot;隶书&quot;)); setbkmode(TRANSPARENT); /*settextcolor(BLUE);*/ BeginBatchDraw();}void 初始化数组a(int a[6][6],int 备份[6][6]){ int i, j; for (i = 1;i &lt; 5;i++) { for (j = 1;j &lt; 5;j++) { a[i][j] = 0; 备份[i][j] = 0; } } for (i = 0;i &lt; 6;i++) { a[i][0] = 5; a[i][5] = 5; a[0][i] = 5; a[5][i] = 5; } int i1, i2, j1, j2; do { i1 = rand() % 4 + 1; i2 = rand() % 4 + 1; j1 = rand() % 4 + 1; j2 = rand() % 4 + 1; } while (i1 == i2 &amp;&amp; j1 == j2); a[i1][j1] = 2; a[i2][j2] = 2;}void 打印a数组(int a[6][6]){ int i, j; for (i = 1;i &lt; 5;i++) { for (j = 1;j &lt; 5;j++) { if (a[i][j] != 0) { TCHAR s[5]; _stprintf_s(s, _T(&quot;%d&quot;), a[i][j]); /*outtextxy(j * 100 + 25, i * 100 + 25, s);*/ RECT r = { 100 * j, 100 * i, 100 + 100 * j, 100 + 100 * i }; drawtext(s, &amp;r, DT_CENTER | DT_VCENTER | DT_SINGLELINE); } } } FlushBatchDraw();}void 备份并初始化计数器(int a[6][6],int 计数器[6][6], int 备份[6][6]){ int i,j; for (i = 0;i &lt; 6;i++) { for (j = 0;j &lt; 6;j++) { 备份[i][j] = a[i][j]; } } for (i = 0;i &lt; 6;i++) { for (j = 0;j &lt; 6;j++) { 计数器[i][j] = 0; } }}void 键盘控制和游戏规则(int a[6][6],int 计数器[6][6]){ int ch, ch1, flag, tmp = 0,i,j,k; if (_kbhit) { ch1 = _getch(); ch = _getch(); //右移 if ((ch1 == 224 &amp;&amp; ch == 77) || (ch == 228 &amp;&amp; ch1 == 163)) { for (i = 1;i &lt;= 4;i++) { for (j = 3;j &gt;= 1;j--) { if (a[i][j] != 0) { flag = j; for (k = j + 1;k &lt;= 4;k++) { if (a[i][k] == 0) flag = k; else break; } //交换aij和aiflag; if (a[i][flag + 1] == a[i][j] &amp;&amp; 计数器[i][flag + 1] == 0) { a[i][flag + 1] *= 2; a[i][j] = 0; 计数器[i][flag + 1] = 1; } else { tmp = a[i][j]; a[i][j] = a[i][flag]; a[i][flag] = tmp; } } } } } //下移 if ((ch1 == 224 &amp;&amp; ch == 80) || (ch == 243 &amp;&amp; ch1 == 163)) { for (j = 1;j &lt;= 4;j++) { for (i = 3;i &gt;= 1;i--) { if (a[i][j] != 0) { flag = i; for (k = i + 1;k &lt;= 4;k++) { if (a[k][j] == 0) flag = k; else break; } /*if (a[i][j] == a[i][j - 1]) { a[i][j- 1] *= 2; a[i][j] = 0; }*/ //交换aij和aiflag; if (a[flag + 1][j] == a[i][j] &amp;&amp; 计数器[flag + 1][j] == 0) { a[flag + 1][j] *= 2; 计数器[flag + 1][j] = 1; a[i][j] = 0; } else { tmp = a[i][j]; a[i][j] = a[flag][j]; a[flag][j] = tmp; } } } } } //上移 if ((ch1 == 224 &amp;&amp; ch == 72) || (ch == 247 &amp;&amp; ch1 == 163)) { for (j = 1;j &lt;= 4;j++) { for (i = 2;i &lt;= 4;i++) { if (a[i][j] != 0) { flag = i; for (k = i - 1;k &gt;= 1;k--) { if (a[k][j] == 0) flag = k; else break; } /*if (a[i][j] == a[i][j - 1]) { a[i][j- 1] *= 2; a[i][j] = 0; }*/ //交换aij和aiflag; if (a[flag - 1][j] == a[i][j] &amp;&amp; 计数器[flag - 1][j] == 0) { a[flag - 1][j] *= 2; 计数器[flag - 1][j] = 1; a[i][j] = 0; } else { tmp = a[i][j]; a[i][j] = a[flag][j]; a[flag][j] = tmp; } } } } } //左移 if ((ch1 == 224 &amp;&amp; ch == 75) || (ch == 225 &amp;&amp; ch1 == 163)) { for (i = 1;i &lt;= 4;i++) { for (j = 2;j &lt;= 4;j++) { if (a[i][j] != 0) { flag = j; for (k = j - 1;k &gt;= 1;k--) { if (a[i][k] == 0) flag = k; else break; } /*if (a[i][j] == a[i][j - 1]) { a[i][j- 1] *= 2; a[i][j] = 0; }*/ //交换aij和aiflag; if (a[i][flag - 1] == a[i][j] &amp;&amp; 计数器[i][flag - 1] == 0) { a[i][flag - 1] *= 2; 计数器[i][flag - 1] = 1; a[i][j] = 0; } else { tmp = a[i][j]; a[i][j] = a[i][flag]; a[i][flag] = tmp; } } } } } }}int 数据备份并判断有无变化(int a[6][6],int 备份[6][6],int 旗子){ int i, j; for (i = 0;i &lt; 6;i++) { for (j = 0;j &lt; 6;j++) { if (备份[i][j] == a[i][j]) 旗子 = 1; else { 旗子 = 0; break; } } if (旗子 == 0) break; } return 旗子;}void 空余位置随机生成一个2或者4(int a[6][6],int 旗子){ int i3, j3, kk; if (旗子 == 0) { do { i3 = rand() % 4 + 1; j3 = rand() % 4 + 1; } while (a[i3][j3] != 0); kk = rand() % 2; if (kk == 1) a[i3][j3] = 2; else a[i3][j3] = 4; }}void 重新绘制屏幕(){ int i, j; cleardevice(); setcolor(BLACK); setfillcolor(YELLOW); for (i = 100;i &lt; 500;i += 100) { for (j = 100;j &lt; 500;j += 100) { rectangle(i, j, 100 + i, j + 100); fillrectangle(i, j, 100 + i, j + 100); } } FlushBatchDraw();}int main(){ using namespace std; 初始化屏幕(); int a[6][6], 备份[6][6],计数器[6][6], 旗子; srand((int)time(0)); 初始化数组a(a, 备份); 打印a数组(a); while (1) { 旗子 = 1; 备份并初始化计数器(a, 计数器, 备份); 键盘控制和游戏规则(a, 计数器); 旗子 = 数据备份并判断有无变化(a, 备份, 旗子); 空余位置随机生成一个2或者4(a,旗子); 重新绘制屏幕(); 打印a数组(a); } return 0;} 4.2048优化版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;#include&lt;conio.h&gt;#include&lt;graphics.h&gt;#include&lt;cmath&gt;int 判断aij是2的几次方(int tt){ int i, sum = 1, cnt = 0; if (tt == 0) return 0; for (i = 1;;i++) { sum *= 2; cnt++; if (sum == tt) break; } return cnt;}void 初始化屏幕(int a[6][6]){ initgraph(1000, 1000); setbkcolor(WHITE); cleardevice(); int i, j,tt,cnt; setcolor(WHITE); settextcolor(RED); for (i = 1;i &lt; 5;i ++) { for (j = 1;j &lt; 5;j ++) { tt = a[i][j]; cnt=判断aij是2的几次方(tt); setfillcolor(RGB(100, 255, 20 * cnt)); rectangle(j * 100, i * 100, 100 + j * 100, i * 100 + 100); fillrectangle(j*100, i*100, 100 + j*100, i*100 + 100); } } settextstyle(30, 20, _T(&quot;隶书&quot;)); setbkmode(TRANSPARENT); /*settextcolor(BLUE);*/ BeginBatchDraw();}void 初始化数组a(int a[6][6], int 备份[6][6]){ int i, j; for (i = 1;i &lt; 5;i++) { for (j = 1;j &lt; 5;j++) { a[i][j] = 0; 备份[i][j] = 0; } } for (i = 0;i &lt; 6;i++) { a[i][0] = 5; a[i][5] = 5; a[0][i] = 5; a[5][i] = 5; } int i1, i2, j1, j2; do { i1 = rand() % 4 + 1; i2 = rand() % 4 + 1; j1 = rand() % 4 + 1; j2 = rand() % 4 + 1; } while (i1 == i2 &amp;&amp; j1 == j2); a[i1][j1] = 2; a[i2][j2] = 2;}void 打印a数组(int a[6][6]){ int i, j; for (i = 1;i &lt; 5;i++) { for (j = 1;j &lt; 5;j++) { if (a[i][j] != 0) { TCHAR s[5]; _stprintf_s(s, _T(&quot;%d&quot;), a[i][j]); /*outtextxy(j * 100 + 25, i * 100 + 25, s);*/ RECT r = { 100 * j, 100 * i, 100 + 100 * j, 100 + 100 * i }; drawtext(s, &amp;r, DT_CENTER | DT_VCENTER | DT_SINGLELINE); } } } FlushBatchDraw();}void 备份并初始化计数器(int a[6][6], int 计数器[6][6], int 备份[6][6]){ int i, j; for (i = 0;i &lt; 6;i++) { for (j = 0;j &lt; 6;j++) { 备份[i][j] = a[i][j]; } } for (i = 0;i &lt; 6;i++) { for (j = 0;j &lt; 6;j++) { 计数器[i][j] = 0; } }}void 键盘控制和游戏规则(int a[6][6], int 计数器[6][6]){ int ch, ch1, flag, tmp = 0, i, j, k; if (_kbhit) { ch1 = _getch(); ch = _getch(); //右移 if ((ch1 == 224 &amp;&amp; ch == 77) || (ch == 228 &amp;&amp; ch1 == 163)) { for (i = 1;i &lt;= 4;i++) { for (j = 3;j &gt;= 1;j--) { if (a[i][j] != 0) { flag = j; for (k = j + 1;k &lt;= 4;k++) { if (a[i][k] == 0) flag = k; else break; } //交换aij和aiflag; if (a[i][flag + 1] == a[i][j] &amp;&amp; 计数器[i][flag + 1] == 0) { a[i][flag + 1] *= 2; a[i][j] = 0; 计数器[i][flag + 1] = 1; } else { tmp = a[i][j]; a[i][j] = a[i][flag]; a[i][flag] = tmp; } } } } } //下移 if ((ch1 == 224 &amp;&amp; ch == 80) || (ch == 243 &amp;&amp; ch1 == 163)) { for (j = 1;j &lt;= 4;j++) { for (i = 3;i &gt;= 1;i--) { if (a[i][j] != 0) { flag = i; for (k = i + 1;k &lt;= 4;k++) { if (a[k][j] == 0) flag = k; else break; } /*if (a[i][j] == a[i][j - 1]) { a[i][j- 1] *= 2; a[i][j] = 0; }*/ //交换aij和aiflag; if (a[flag + 1][j] == a[i][j] &amp;&amp; 计数器[flag + 1][j] == 0) { a[flag + 1][j] *= 2; 计数器[flag + 1][j] = 1; a[i][j] = 0; } else { tmp = a[i][j]; a[i][j] = a[flag][j]; a[flag][j] = tmp; } } } } } //上移 if ((ch1 == 224 &amp;&amp; ch == 72) || (ch == 247 &amp;&amp; ch1 == 163)) { for (j = 1;j &lt;= 4;j++) { for (i = 2;i &lt;= 4;i++) { if (a[i][j] != 0) { flag = i; for (k = i - 1;k &gt;= 1;k--) { if (a[k][j] == 0) flag = k; else break; } /*if (a[i][j] == a[i][j - 1]) { a[i][j- 1] *= 2; a[i][j] = 0; }*/ //交换aij和aiflag; if (a[flag - 1][j] == a[i][j] &amp;&amp; 计数器[flag - 1][j] == 0) { a[flag - 1][j] *= 2; 计数器[flag - 1][j] = 1; a[i][j] = 0; } else { tmp = a[i][j]; a[i][j] = a[flag][j]; a[flag][j] = tmp; } } } } } //左移 if ((ch1 == 224 &amp;&amp; ch == 75) || (ch == 225 &amp;&amp; ch1 == 163)) { for (i = 1;i &lt;= 4;i++) { for (j = 2;j &lt;= 4;j++) { if (a[i][j] != 0) { flag = j; for (k = j - 1;k &gt;= 1;k--) { if (a[i][k] == 0) flag = k; else break; } /*if (a[i][j] == a[i][j - 1]) { a[i][j- 1] *= 2; a[i][j] = 0; }*/ //交换aij和aiflag; if (a[i][flag - 1] == a[i][j] &amp;&amp; 计数器[i][flag - 1] == 0) { a[i][flag - 1] *= 2; 计数器[i][flag - 1] = 1; a[i][j] = 0; } else { tmp = a[i][j]; a[i][j] = a[i][flag]; a[i][flag] = tmp; } } } } } }}int 数据备份并判断有无变化(int a[6][6], int 备份[6][6], int 旗子){ int i, j; for (i = 0;i &lt; 6;i++) { for (j = 0;j &lt; 6;j++) { if (备份[i][j] == a[i][j]) 旗子 = 1; else { 旗子 = 0; break; } } if (旗子 == 0) break; } return 旗子;}void 空余位置随机生成一个2或者4(int a[6][6], int 旗子){ int i3, j3, kk; if (旗子 == 0) { do { i3 = rand() % 4 + 1; j3 = rand() % 4 + 1; } while (a[i3][j3] != 0); kk = rand() % 2; if (kk == 1) a[i3][j3] = 2; else a[i3][j3] = 4; }}void 重新绘制屏幕(int a[6][6]){ int i, j,tt,cnt; cleardevice(); setcolor(WHITE); settextcolor(RED); for (i = 1;i &lt; 5;i++) { for (j = 1;j &lt; 5;j++) { tt = a[i][j]; cnt = 判断aij是2的几次方(tt); setfillcolor(RGB(100, 255, 20 * cnt)); rectangle(j * 100, i * 100, 100 + j * 100, i * 100 + 100); fillrectangle(j * 100, i * 100, 100 + j * 100, i * 100 + 100); } } FlushBatchDraw();}int main(){ using namespace std; int a[6][6], 备份[6][6], 计数器[6][6], 旗子; srand((int)time(0)); 初始化数组a(a, 备份); 初始化屏幕(a); 打印a数组(a); while (1) { 旗子 = 1; 备份并初始化计数器(a, 计数器, 备份); 键盘控制和游戏规则(a, 计数器); 旗子 = 数据备份并判断有无变化(a, 备份, 旗子); 空余位置随机生成一个2或者4(a, 旗子); 重新绘制屏幕(a); 打印a数组(a); } return 0;} 似乎只改动了颜色","link":"/2021/01/02/2048%E5%B0%8F%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"源码","slug":"源码","link":"/tags/%E6%BA%90%E7%A0%81/"},{"name":"经典","slug":"经典","link":"/tags/%E7%BB%8F%E5%85%B8/"}],"categories":[]}