{"pages":[],"posts":[{"title":"矩阵计算器","text":"线代必备工具 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;time.h&gt;#include&lt;graphics.h&gt;#include&lt;conio.h&gt;#include&lt;fstream&gt;#include&lt;string&gt;#include&lt;iostream&gt;double** 生成矩阵(double** a, int* r, int* c);double 计算行列式(double** a, int n);void 打开菜单();int 执行程序();void 写入文件(double** a, int r1, int c1, double** d, int r2, int c2, std::string name);void 写入逆矩阵(double** a, double** d, int r, std::string name);void 写入行列式(double** a, int r, double ss);void 写入秩(double** a, int r1, int c1, int 秩);void 写入加减法(double** a, int r1, int c1, double** b, double** d, int r, int c, int sign);void 写入乘法(double** a, int r1, int c1, double** b, int r2, int c2, double** d);void 读取文件();void 矩阵转置(double** a, int r, int c);void 矩阵加减法(double** a, double** b, int r1, int c1, int r2, int c2, int sign);void 矩阵数乘(double** a, int r, int c);void 矩阵乘法(double** a, double** b, int r1, int c1, int r2, int c2);int 矩阵化简(double** a, int r, int c, int sign);void 矩阵求逆(double** a, int r);void 打印d数组(double** d, int r, int c);void 打印d数组(double** d, int r);void 内存释放(double** d, int r);int main(){ int 开始; do { 打开菜单(); 开始 = 执行程序(); } while (开始 == 0);}void 矩阵转置(double** a, int r, int c){ double** d = NULL; d = new double* [c]; for (int i = 0; i &lt; c; i++) { d[i] = new double[r]; } for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; c; j++) { d[j][i] = a[i][j]; } } 打印d数组(d, c, r); 写入文件(a, r, c, d, c, r, &quot;的转置为：&quot;); 内存释放(d, c);}void 矩阵加减法(double** a, double** b, int r1, int c1, int r2, int c2, int sign){ if (r1 == r2 &amp;&amp; c1 == c1) { double** d = NULL; d = new double* [r1]; for (int i = 0; i &lt; r1; i++) { d[i] = new double[c1]; } for (int i = 0; i &lt; r1; i++) { for (int j = 0; j &lt; c1; j++) { d[i][j] = a[i][j] + b[i][j] * sign; } } 打印d数组(d, r1, c1); 写入加减法(a, r1, c1, b, d, r1, c1, sign); 内存释放(d, r1); } else printf(&quot;这两个矩阵不可以这样运算！&quot;);}void 矩阵数乘(double** a, int r, int c){ double** d = NULL; d = new double* [r]; for (int i = 0; i &lt; r; i++) { d[i] = new double[c]; } int k; printf(&quot;请输入数值：&quot;); scanf_s(&quot;%d&quot;, &amp;k); for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; c; j++) { d[i][j] = k * a[i][j]; } } 打印d数组(d, r, c); std::to_string(k); std::string name = &quot;数乘&quot; + std::to_string(k) + &quot;的结果为：&quot;; 写入文件(a, r, c, d, r, c, name); 内存释放(d, r);}void 矩阵乘法(double** a, double** b, int r1, int c1, int r2, int c2){ if (r2 == c1) { double** d = NULL, sum; d = new double* [r1]; for (int i = 0; i &lt; r1; i++) { d[i] = new double[c2]; } for (int i = 0; i &lt; r1; i++) { for (int j = 0; j &lt; c2; j++) { sum = 0; for (int k = 0; k &lt; c1; k++) { sum += a[i][k] * b[k][j]; } d[i][j] = sum; } } 打印d数组(d, r1, c2); 写入乘法(a, r1, c1, b, r2, c2, d); 内存释放(d, r1); } else printf(&quot;这两个矩阵不能相乘！&quot;);}int 矩阵化简(double** a, int r, int c, int sign){ double** d; d = new double* [r]; for (int i = 0; i &lt; r; i++) { d[i] = new double[c]; } for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; c; j++) { d[i][j] = a[i][j]; } } //起始行列 int cnt = 0; int cct = 0; int flag; double t; while (cnt &lt;= r &amp;&amp; cct &lt;= c) { flag = -1; for (int i = cnt; i &lt; r; i++) { if (d[i][cct] != 0) { flag = i; break; } } if (flag == -1) { cct++; continue; } //交换两行; if (flag != cnt) { double tmp = 0; for (int j = cct; j &lt; c; j++) { tmp = d[flag][j]; d[flag][j] = d[cnt][j]; d[cnt][j] = tmp; } } //化第一行首个为1 t = d[cnt][cct]; for (int j = cct; j &lt; c; j++) { d[cnt][j] /= t; } for (int i = cnt + 1; i &lt; r; i++) { if (d[i][cct] != 0) { t = d[i][cct]; for (int j = cct; j &lt; c; j++) { d[i][j] = d[i][j] - d[cnt][j] * t; } } } cnt++; cct++; } for (int i = r - 1; i &gt; 0; i--) { flag = -1; for (int j = 0; j &lt; c; j++) { if (d[i][j] != 0) { flag = j; break; } } if (flag != -1) { for (int k = i - 1; k &gt;= 0; k--) { t = d[k][flag]; for (int j = 0; j &lt; c; j++) { d[k][j] = d[k][j] - t * d[i][j]; } } } } int number = 0; for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; c; j++) { if (d[i][j] != 0) { number++; break; } } } if (sign == 0) { 打印d数组(d, r, c); 写入文件(a, r, c, d, r, c, &quot;的化简结果为：&quot;); } else { 打印d数组(d, r); 写入逆矩阵(a, d,r, &quot;的逆矩阵为: &quot;); } 内存释放(d, r); return number;}void 矩阵求逆(double** a, int r){ if (计算行列式(a, r) != 0) { double** d; d = new double* [r]; for (int i = 0; i &lt; r; i++) { d[i] = new double[2 * r]; } for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; r; j++) { d[i][j] = a[i][j]; } for (int j = r; j &lt; 2 * r; j++) { if (i == j - r) d[i][j] = 1; else d[i][j] = 0; } } 矩阵化简(d, r, 2 * r, 1); 内存释放(d, r); } else printf(&quot;这个矩阵不可逆！&quot;);}void 打印d数组(double** d, int r, int c){ printf(&quot;结果如下：\\n&quot;); for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; c; j++) { if ((int)(d[i][j] * 100) % 100 == 0) printf(&quot;%d\\t&quot;, (int)d[i][j]); else printf(&quot;%.2lf\\t&quot;, d[i][j]); } printf(&quot;\\n&quot;); }}void 打印d数组(double** d, int r){ printf(&quot;结果如下：\\n&quot;); for (int i = 0; i &lt; r; i++) { for (int j = r; j &lt; 2 * r; j++) { if ((int)(d[i][j] * 100) % 100 == 0) printf(&quot;%d\\t&quot;, (int)d[i][j]); else printf(&quot;%.2lf\\t&quot;, d[i][j]); } printf(&quot;\\n&quot;); }}double 计算行列式(double** a, int n){ double** d; d = new double* [n]; for (int i = 0; i &lt; n; i++) { d[i] = new double[n]; } for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { d[j][i] = a[i][j]; } } int flag = -1; for (int i = 0; i &lt; n; i++) { if (d[i][0] != 0) { flag = i; break; } } if (flag != 0) { double tmp = 0; for (int j = 0; j &lt; n; j++) { tmp = d[flag][j]; d[flag][j] = d[0][j]; d[0][j] = tmp; } } double tmp; for (int k = 1; k &lt; n; k++) { for (int i = k; i &lt; n; i++) { tmp = d[i][k - 1] / d[k - 1][k - 1]; for (int j = k - 1; j &lt; n; j++) { d[i][j] = d[i][j] - tmp * d[k - 1][j]; } } } double ss = 1; for (int i = 0; i &lt; n; i++) { ss *= d[i][i]; } 写入行列式(a, n, ss); 内存释放(d, n); return ss;}double** 生成矩阵(double** a, int* r, int* c){ printf(&quot;请输入矩阵的行数，列数：&quot;); scanf_s(&quot;%d%d&quot;, r, c); printf(&quot;请输入矩阵：\\n&quot;); a = new double* [*r]; for (int i = 0; i &lt; *r; i++) { a[i] = new double[*c]; } for (int i = 0; i &lt; *r; i++) { for (int j = 0; j &lt; *c; j++) { scanf_s(&quot;%lf&quot;, &amp;a[i][j]); } } return a;}void 打开菜单(){ printf(&quot;=======================================================================\\n&quot;); printf(&quot;| ----------1|我要求矩阵的加法 ----------- |\\n&quot;); printf(&quot;| ----------2|我要求矩阵的减法 ----------- |\\n&quot;); printf(&quot;| ----------3|我要求矩阵的转置 ----------- |\\n&quot;); printf(&quot;| ----------4|我要求矩阵的逆矩阵----------- |\\n&quot;); printf(&quot;| ----------5|我要求最简行矩阵 ----------- |\\n&quot;); printf(&quot;| ----------6|我要求矩阵的数乘 ----------- |\\n&quot;); printf(&quot;| ----------7|我要求矩阵的乘法 ----------- |\\n&quot;); printf(&quot;| ----------8|我要求矩阵的秩 ----------- |\\n&quot;); printf(&quot;| ----------9|我要计算行列式的值----------- |\\n&quot;); printf(&quot;| ----------0|读取计算结果文件 ----------- |\\n&quot;); printf(&quot;| ----------QAQ|输入字母可以退出----------- |\\n&quot;); printf(&quot;=======================================================================\\n&quot;);}int 执行程序(){ double** a = NULL, ** b = NULL; int r1, c1, r2, c2; char ch; switch (ch = getchar()) { case'1': { a = 生成矩阵(a, &amp;r1, &amp;c1); b = 生成矩阵(b, &amp;r2, &amp;c2); 矩阵加减法(a, b, r1, c1, r2, c2, 1); 内存释放(a, r1); 内存释放(b, r2); break; } case'2': { a = 生成矩阵(a, &amp;r1, &amp;c1); b = 生成矩阵(b, &amp;r2, &amp;c2); 矩阵加减法(a, b, r1, c1, r2, c2, -1); 内存释放(a, r1); 内存释放(b, r2); break; } case'3': { a = 生成矩阵(a, &amp;r1, &amp;c1); 矩阵转置(a, r1, c1); 内存释放(a, r1); break; } case'4': { a = 生成矩阵(a, &amp;r1, &amp;c1); 矩阵求逆(a, r1); 内存释放(a, r1); break; } case'5': { a = 生成矩阵(a, &amp;r1, &amp;c1); 矩阵化简(a, r1, c1, 0); 内存释放(a, r1); break; } case'6': { a = 生成矩阵(a, &amp;r1, &amp;c1); 矩阵数乘(a, r1, c1); 内存释放(a, r1); break; } case'7': { a = 生成矩阵(a, &amp;r1, &amp;c1); b = 生成矩阵(b, &amp;r2, &amp;c2); 矩阵乘法(a, b, r1, c1, r2, c2); 内存释放(a, r1); 内存释放(b, r2); break; } case'8': { a = 生成矩阵(a, &amp;r1, &amp;c1); int 秩; 秩 = 矩阵化简(a, r1, c1, 0); printf(&quot;矩阵的秩为：%d\\n&quot;, 秩); 内存释放(a, r1); break; } case'9': { a = 生成矩阵(a, &amp;r1, &amp;c1); double ss = 计算行列式(a, r1); if ((int)(ss * 100) % 100 == 0) printf(&quot;%d\\t&quot;, (int)ss); else printf(&quot;%.2lf\\t&quot;, ss); 内存释放(a, r1); break; } case '0': { 读取文件(); break; } default: { return -1; } } getchar(); return 0;}void 内存释放(double** d, int r){ for (int i = 0; i &lt; r; i++) { delete[]d[i]; } delete[]d;}void 写入文件(double** a, int r1, int c1, double** d, int r2, int c2,std::string name){ using namespace std; string 文件名; 文件名 = &quot;计算结果.txt&quot;; ofstream fout(文件名.c_str(),ios_base::out|ios_base::app); fout &lt;&lt; &quot;矩阵：&quot; &lt;&lt; endl; for (int i = 0; i &lt; r1; i++) { for (int j = 0; j &lt; c1; j++) { if ((int)(a[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)a[i][j] &lt;&lt; &quot;\\t&quot;; else { fout &lt;&lt; a[i][j] &lt;&lt; &quot;\\t&quot;; } } fout &lt;&lt; endl; } fout &lt;&lt; name &lt;&lt; endl; for (int i = 0; i &lt; r2; i++) { for (int j = 0; j &lt; c2; j++) { if ((int)(d[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)d[i][j] &lt;&lt; &quot;\\t&quot;; else fout &lt;&lt; d[i][j] &lt;&lt; &quot;\\t&quot;; } fout &lt;&lt; endl; }}void 写入逆矩阵(double** a, double** d,int r, std::string name){ using namespace std; string 文件名; 文件名 = &quot;计算结果.txt&quot;; ofstream fout(文件名.c_str(), ios_base::out | ios_base::app); fout &lt;&lt; &quot;矩阵：&quot; &lt;&lt; endl; for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; r; j++) { if ((int)(a[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)a[i][j] &lt;&lt; &quot;\\t&quot;; else { fout &lt;&lt; a[i][j] &lt;&lt; &quot;\\t&quot;; } } fout &lt;&lt; endl; } fout &lt;&lt; name &lt;&lt; endl; for (int i = 0; i &lt; r; i++) { for (int j = r; j &lt; 2*r; j++) { if ((int)(d[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)d[i][j] &lt;&lt; &quot;\\t&quot;; else { fout &lt;&lt; d[i][j] &lt;&lt; &quot;\\t&quot;; } } fout &lt;&lt; endl; }}void 写入行列式(double** a, int r,double ss){ using namespace std; string 文件名; 文件名 = &quot;计算结果.txt&quot;; ofstream fout(文件名.c_str(), ios_base::out | ios_base::app); fout &lt;&lt; &quot;矩阵：&quot; &lt;&lt; endl; for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; r; j++) { if ((int)(a[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)a[i][j] &lt;&lt; &quot;\\t&quot;; else { fout &lt;&lt; a[i][j] &lt;&lt; &quot;\\t&quot;; } } fout &lt;&lt; endl; } fout &lt;&lt; &quot;的行列式的值为：&quot; &lt;&lt; ss &lt;&lt; endl;}void 写入秩(double** a, int r1, int c1, int 秩){ using namespace std; string 文件名; 文件名 = &quot;计算结果.txt&quot;; ofstream fout(文件名.c_str(), ios_base::out | ios_base::app); fout &lt;&lt; &quot;矩阵：&quot; &lt;&lt; endl; for (int i = 0; i &lt; r1; i++) { for (int j = 0; j &lt; 1; j++) { if ((int)(a[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)a[i][j] &lt;&lt; &quot;\\t&quot;; else { fout &lt;&lt; a[i][j] &lt;&lt; &quot;\\t&quot;; } } fout &lt;&lt; endl; } fout &lt;&lt; &quot;的秩为：&quot; &lt;&lt; 秩 &lt;&lt; endl;}void 写入加减法(double** a, int r1, int c1, double** b,double**d,int r,int c, int sign){ using namespace std; string 文件名; 文件名 = &quot;计算结果.txt&quot;; ofstream fout(文件名.c_str(), ios_base::out | ios_base::app); fout &lt;&lt; &quot;矩阵：&quot; &lt;&lt; endl; for (int i = 0; i &lt; r1; i++) { for (int j = 0; j &lt; c1; j++) { if ((int)(a[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)a[i][j] &lt;&lt; &quot;\\t&quot;; else { fout &lt;&lt; a[i][j] &lt;&lt; &quot;\\t&quot;; } } fout &lt;&lt; endl; } if (sign == 1) { fout &lt;&lt; &quot;加矩阵：&quot; &lt;&lt; endl; } else { fout &lt;&lt; &quot;减矩阵：&quot; &lt;&lt; endl; } for (int i = 0; i &lt; r1; i++) { for (int j = 0; j &lt; c1; j++) { if ((int)(b[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)b[i][j] &lt;&lt; &quot;\\t&quot;; else fout &lt;&lt; b[i][j] &lt;&lt; &quot;\\t&quot;; } fout &lt;&lt; endl; } fout &lt;&lt; &quot;的结果为：&quot; &lt;&lt; endl; for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; c; j++) { if ((int)(d[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)d[i][j] &lt;&lt; &quot;\\t&quot;; else fout &lt;&lt; d[i][j] &lt;&lt; &quot;\\t&quot;; } fout &lt;&lt; endl; }}void 写入乘法(double**a,int r1,int c1,double**b,int r2,int c2,double**d){ using namespace std; string 文件名; 文件名 = &quot;计算结果.txt&quot;; ofstream fout(文件名.c_str(), ios_base::out | ios_base::app); fout &lt;&lt; &quot;矩阵：&quot; &lt;&lt; endl; for (int i = 0; i &lt; r1; i++) { for (int j = 0; j &lt; c1; j++) { if ((int)(a[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)a[i][j] &lt;&lt; &quot;\\t&quot;; else { fout &lt;&lt; a[i][j] &lt;&lt; &quot;\\t&quot;; } } fout &lt;&lt; endl; } fout &lt;&lt; &quot;乘矩阵：&quot; &lt;&lt; endl; for (int i = 0; i &lt; r2; i++) { for (int j = 0; j &lt; c2; j++) { if ((int)(b[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)b[i][j] &lt;&lt; &quot;\\t&quot;; else fout &lt;&lt; b[i][j] &lt;&lt; &quot;\\t&quot;; } fout &lt;&lt; endl; } fout &lt;&lt; &quot;的结果为：&quot; &lt;&lt; endl; for (int i = 0; i &lt; r1; i++) { for (int j = 0; j &lt; c2; j++) { if ((int)(d[i][j] * 100) % 100 == 0) fout &lt;&lt; (int)d[i][j] &lt;&lt; &quot;\\t&quot;; else fout &lt;&lt; d[i][j] &lt;&lt; &quot;\\t&quot;; } fout &lt;&lt; endl; }}void 读取文件(){ using namespace std; char ch; string 文件名; 文件名 = &quot;计算结果.txt&quot;; ifstream fin(文件名); if (fin.is_open()) { while (fin.get(ch)) { cout &lt;&lt; ch; } fin.close(); }}","link":"/2020/12/31/%E7%9F%A9%E9%98%B5%E8%AE%A1%E7%AE%97%E5%99%A8/"}],"tags":[{"name":"源码","slug":"源码","link":"/tags/%E6%BA%90%E7%A0%81/"}],"categories":[]}